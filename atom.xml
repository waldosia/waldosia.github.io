<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>waldosia的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://waldosia.github.io/"/>
  <updated>2018-07-20T12:31:03.721Z</updated>
  <id>https://waldosia.github.io/</id>
  
  <author>
    <name>waldosia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>英语资料上传管理系统总结</title>
    <link href="https://waldosia.github.io/2018/06/20/SecondProjectSummary/"/>
    <id>https://waldosia.github.io/2018/06/20/SecondProjectSummary/</id>
    <published>2018-06-20T11:46:00.000Z</published>
    <updated>2018-07-20T12:31:03.721Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>开启两个react app时，显示Something is already running on port 3000.</strong><br>解决：<code>PORT=3001 npm start</code></p></li><li><p><strong>Import相对路径引用</strong><br>‘./同一文件夹内文件’<br>‘../父级文件夹兄弟文件’</p></li><li><p><strong>npm i 依赖安装 报错 error -4058 syscall access</strong><br>解决：使用cnpm i   </p></li><li><p><strong>报错Each child in an array or iterator should have a unique “key” prop.</strong><br>原代码      </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgList = imgStr.map(<span class="function">(<span class="params">image</span>) =&gt;</span></span><br><span class="line">   &lt;li className=<span class="string">"icon-wrap"</span>&gt;&lt;img src=&#123;image&#125; alt=""/&gt;&lt;/li&gt;react</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>修改后     </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgList = imgStr.map(<span class="function">(<span class="params">image,i</span>) =&gt;</span></span><br><span class="line">  &lt;li className=<span class="string">"icon-wrap"</span> key=&#123;i&#125;&gt;&lt;img src=&#123;image&#125; alt=""/&gt;&lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>同一行文字图片不对齐</strong><br>解决： 给文字设置<code>vertical-align: top;</code>属性。</p></li><li><p><strong>‘props’ is not defined</strong><br>解决：props调用前需要加this，<code>{this.props.image}</code>。   </p></li><li><p><strong>修改state数组中某一个</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">   <span class="keyword">super</span>(props);</span><br><span class="line">   <span class="keyword">this</span>.state = &#123;<span class="attr">open</span>: [<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>]&#125;;</span><br><span class="line">   <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleClick(i) &#123;</span><br><span class="line">   <span class="keyword">let</span> state = <span class="keyword">this</span>.state;</span><br><span class="line">   state[i] = !state[i];</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">state</span>: state&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Map事件绑定</strong><br>需要先将map变量保存在变量中再输出。为什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">   <span class="keyword">let</span> wideList = listStr.map(<span class="function">(<span class="params">it, i</span>) =&gt;</span></span><br><span class="line">     &lt;li className=<span class="string">"list-wrap"</span> key=&#123;i&#125; &gt;</span><br><span class="line">       &lt;div className=<span class="string">"big-list"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>, i)&#125;&gt;</span><br><span class="line">         &lt;img src=&#123;it.image&#125; alt=<span class="string">""</span>/&gt;</span><br><span class="line">         &lt;span&gt;&#123;it.name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">       &lt;/</span>div&gt;</span><br><span class="line">   &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">   return (</span></span><br><span class="line"><span class="regexp">     &lt;div className="wider-sidebar"&gt;</span></span><br><span class="line"><span class="regexp">       &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">         &#123;wideList&#125;</span></span><br><span class="line"><span class="regexp">       &lt;/u</span>l&gt;</span><br><span class="line">     &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>子组件向父组件传递数据</strong><br>父：父组件传递带参函数，参数为子组件需要向父组件传递的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typeChange(i, typeStr)&#123;</span><br><span class="line">  <span class="keyword">let</span> newType = <span class="keyword">this</span>.state.type;</span><br><span class="line">  newType[i] = typeStr;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      type: newType</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;SelectBox typeChange=&#123;<span class="keyword">this</span>.typeChange.bind(<span class="keyword">this</span>)&#125;/&gt;或者</span><br><span class="line">&lt;SelectBox typeChange=&#123;(i, typeStr) =&gt; <span class="keyword">this</span>.typeChange(i, typeStr)</span><br><span class="line">&#125;/&gt;</span><br></pre></td></tr></table></figure></li></ol><p>子:子组件调用父组件函数，传入需要传递的参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleChange(i, e)&#123;</span><br><span class="line">    <span class="keyword">this</span>.props.typeChange(i, <span class="keyword">this</span>.state.type[i]);<span class="comment">//调用父组件函数</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;input type=<span class="string">"text"</span></span><br><span class="line">    list=&#123;<span class="string">'type'</span> + (index+<span class="number">1</span>)&#125;</span><br><span class="line">       value=&#123;<span class="keyword">this</span>.state.type[index]&#125;</span><br><span class="line">       onChange=&#123;<span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>,index)&#125;/&gt;</span><br></pre></td></tr></table></figure></p><ol start="10"><li><p><strong>Js函数全角改半角</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">changeMark(str)&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charCodeAt(i) &gt;= <span class="number">65281</span> &amp;&amp; str.charCodeAt(i) &lt;= <span class="number">65374</span>)&#123;<span class="comment">// 如果位于全角！到全角～区间内</span></span><br><span class="line">            tmp += <span class="built_in">String</span>.fromCharCode(str.charCodeAt(i)<span class="number">-65248</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charCodeAt(i) === <span class="number">12288</span>)&#123;<span class="comment">//全角空格的值，它没有遵从与ASCII的相对偏移，必须单独处理</span></span><br><span class="line">            tmp += <span class="string">' '</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 不处理全角空格，全角！到全角～区间外的字符</span></span><br><span class="line">            tmp += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>按符号分割字符串。</strong><br>开始想着是用split，但是split会把标点符号给删了，不行。<br>解决1. 用match<br>找到与句子匹配的正则<br><code>str.match(reg);</code>直接分割，但是正则表达式没有找着，后续学习。。<br>解决2. 函数exec</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastindex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((r=reg.exec(articleStr))!==<span class="literal">null</span>)&#123;</span><br><span class="line">    sentenceArr.push(articleStr.substring(lastindex, r.index+<span class="number">1</span>));</span><br><span class="line">    lastindex=reg.lastIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Constructor中的super什么意思？</strong></p></li><li><p><strong>React单选框组件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"rightAnswer"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">checked</span>=<span class="string">&#123;this.state.rightAnswer</span> === <span class="string">this.state.value&#125;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">onClick</span>=<span class="string">&#123;this.rightAnswerChange.bind(this,</span> <span class="attr">index</span>)&#125;</span></span><br><span class="line"><span class="tag"><span class="attr">onChange</span>=<span class="string">&#123;this.rightAnswerChange.bind(this,</span> <span class="attr">index</span>)&#125;/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>正确答案<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Axios执行post请求时，后来获取不到数据，提示Required XXX parameter XXX is not present.</strong><br>先前写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data=&#123;</span><br><span class="line">    sentence_contents: sentenceArr,</span><br><span class="line">    lesson_type_id: <span class="number">1</span>,</span><br><span class="line">    owner_id: <span class="number">1</span></span><br><span class="line"> &#125;;</span><br><span class="line">axios.post(<span class="string">'https://pay.regiondavid.xyz/Qidian-test/lessonEdit/init_sentences'</span>, data,&#123;</span><br><span class="line">     headers: &#123;</span><br><span class="line">         <span class="comment">/* 一些公用的 header */</span></span><br><span class="line"><span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">     &#125;,</span><br><span class="line">     crossDomain: <span class="literal">true</span>,</span><br><span class="line">     withCredentials: <span class="literal">true</span></span><br><span class="line"> &#125;)</span><br><span class="line">     .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(res);</span><br><span class="line">     &#125;)</span><br><span class="line">     .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure></li></ol><p>解决： post参数传递要以<br><code>&quot;userName=&#39;n&#39;&amp; phone=&#39;13&#39;&amp; email=&#39;12&#39;&amp; emailPwd=&#39;22&#39;&amp; kindleEmail=&#39;asd&#39;&quot;</code><br>形式传递<br>而上面传递的为对象格式<br>解决方案1：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">data.append(<span class="string">"sentence_contents"</span>, <span class="string">'[a,a]'</span>);</span><br><span class="line">data.append(<span class="string">"lesson_type_id"</span>, <span class="number">1</span>);</span><br><span class="line">data.append(<span class="string">"owner_id"</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>解决方案2：封装一个axios实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个新的 AXIOS 对象，确保原有的对象不变 */</span></span><br><span class="line"><span class="keyword">let</span> axiosWrap = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'https://pay.regiondavid.xyz/Qidian-test'</span><span class="comment">/* 服务器的根路径 */</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="comment">/* 一些公用的 header */</span></span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    crossDomain: <span class="literal">true</span>,</span><br><span class="line">    withCredentials: <span class="literal">true</span>,</span><br><span class="line">    transformRequest:[<span class="function"><span class="keyword">function</span> (<span class="params">data, header</span>)</span>&#123;</span><br><span class="line">        <span class="comment">/* 自定义请求参数解析方式（如果必要的话）修改传递data格式 */</span></span><br><span class="line">        <span class="keyword">let</span> ret = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">in</span> data) &#123;</span><br><span class="line">            ret += <span class="built_in">encodeURIComponent</span>(it) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[it]) + <span class="string">'&amp;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;],</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axiosWrap</span><br></pre></td></tr></table></figure></p><p>调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data=&#123;</span><br><span class="line">    sentence_contents: sentenceArr,</span><br><span class="line">    lesson_type_id: <span class="number">1</span>,</span><br><span class="line">    owner_id: <span class="number">1</span></span><br><span class="line"> &#125;;</span><br><span class="line">axiosWrap.post(<span class="string">'/lessonEdit/init_sentences'</span>,data)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><ol start="15"><li><strong>React中props传递的数据类型为数组时，子组件讲改传递值作为了state并修改了他，父组件中相应数组也会跟着修改。</strong><br>父：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text1Edit</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">                sentenceArr: [‘a’,’b’,’c’]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.sentenceArr);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"text1-edit"</span>&gt;</span><br><span class="line">                &#123; <span class="keyword">this</span>.state.sentenceArr &#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceArea</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">let</span> sentenceArr = <span class="keyword">this</span>.props.arr;</span><br><span class="line">        sentenceArr.shift();</span><br><span class="line">        <span class="comment">// console.log(sentenceArr);</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            title: <span class="keyword">this</span>.props.arr[<span class="number">0</span>],</span><br><span class="line">            sentenceArr: sentenceArr,  <span class="comment">//句子字符串</span></span><br><span class="line">            <span class="comment">// sentences : this.props.arr.substring(1),</span></span><br><span class="line">            firstIndex: <span class="literal">NaN</span>,<span class="comment">//第一次点击的句子索引</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>解决：复杂类型利用=传值传递的均为地址，即所有对象均指向一个地址，修改一个全部都会改变，所以应该在子组件实现深拷贝，即实现数组的一个备份。</p><ol start="16"><li><p><strong>Ajax传递复杂对象类型时，如{a:2,b:{a:1,b:2}}时，直接对该data无法编码，需要预先将b对应的对象转为Json字符串，再传递。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    sequence: <span class="keyword">this</span>.state.sequence,</span><br><span class="line">    type: <span class="keyword">this</span>.state.type,</span><br><span class="line">    question: <span class="keyword">this</span>.state.question,</span><br><span class="line">    options: <span class="keyword">this</span>.state.options,</span><br><span class="line">    answer: <span class="keyword">this</span>.state.answer</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dataStr = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">axiosWrap.post(<span class="string">'/lessonEdit/upload_reading_comprehension'</span>, &#123;</span><br><span class="line">    reading_comprehension : dataStr,</span><br><span class="line">    lesson_id : <span class="keyword">this</span>.state.lesson_id</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>Ajax更新父组件State时，传入子组件的props转换为state没有更新，</strong><br>解决：<br>1.(暴力方法)通过给子组件添加不同的key即可，这样在每次父组件执行render方法的时候，发现key不相同，则会重新加载子组件；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Par</span> <span class="title">entend</span> <span class="title">React</span>.<span class="title">PureComponent</span></span>&#123;</span><br><span class="line">render()&#123;</span><br><span class="line">    &lt;Son key=<span class="built_in">Math</span>.random()/&gt; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2.这种方式，由于我们使用的是state，所以每当父组件每次重新传递props时，我们需要重新处理下，将props转换成自己的state，这里就用到了componentWillReceiveProps。在componentWillReceiveProps中this.props为老的props值，需要引用nextProps获取新的props的值。当父组件的的props更新时，子组件的this.props的值也是从render函数开始执行的时候开始更新的，render之前生命周期函数中都是获取不到最新的this.props的，除非用this.props=nextProps进行更新。<br>关于你提到的不会二次渲染是这样的：每次子组件接收到新的props，都会重新渲染一次，除非你做了处理来阻止（比如使用：shouldComponentUpdate），但是你可以在这次渲染前，根据新的props更新state，更新state也会触发一次重新渲染，但react不会这么傻，所以只会渲染一次，这对应用的性能是有利的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            someThings: props.someThings</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">someThings</span>: nextProps.someThings&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.someThings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="18"><li><p><strong>不用link利用js实现跳转</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionEdit</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.props.history.push(<span class="string">'/Text2Edit'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(QuestionEdit);</span><br></pre></td></tr></table></figure></li><li><p><strong>对象属性名通过(.)与([])调用区别</strong><br>(.)调用时，后面必须为字符串。<br>([])调用时，中间可以为变量。</p></li><li><p><strong>git过滤文件以及文件夹</strong><br>1）    在根目录中创建.gitignore.txt文件，或者在需要创建.gitignore文件的文件夹内进入命令行，输入touch .gitignore即可。<br>2）    在.gitignore文件里输入你要忽略的文件夹及其文件就可以了。<br>文件夹用bin/表示，文件后缀用*.dll表示.</p></li><li><p><strong>prevState</strong>   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>(&#123;<span class="attr">voicePlay</span>: !prevState.voicePlay&#125;))</span><br></pre></td></tr></table></figure></li><li><p><strong>html5语音控制播放暂停</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">voicePlay()&#123;</span><br><span class="line">    <span class="keyword">let</span> audio=<span class="built_in">document</span>.getElementById(<span class="string">'audio'</span>);</span><br><span class="line">    <span class="keyword">if</span> (audio.paused) &#123;</span><br><span class="line">        audio.play();</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">voicePlay</span>: <span class="string">'停止'</span>&#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        audio.pause();</span><br><span class="line">        audio.currentTime = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">voicePlay</span>: <span class="string">'停止'</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.voicePlay.bind(<span class="keyword">this</span>)&#125;&gt;&#123;<span class="keyword">this</span>.state.voicePlay&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;audio id='audio'&gt;</span></span><br><span class="line"><span class="regexp">    &lt;source src=&#123;a&#125; type="audio/m</span>peg<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">&lt;/audio&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>动态修改state，封装成函数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stateChange(prop, val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;[prop]: val&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>深拷贝</strong><br>深拷贝对象还有另一个解决方法，在对象中不含有函数的时候，使用JSON解析反解析就可以得到一个深拷贝对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;开启两个react app时，显示Something is already running on port 3000.&lt;/strong&gt;&lt;br&gt;解决：&lt;code&gt;PORT=3001 npm start&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="项目总结" scheme="https://waldosia.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="react" scheme="https://waldosia.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>BFPRT算法之js实现</title>
    <link href="https://waldosia.github.io/2018/05/25/BFPRT/"/>
    <id>https://waldosia.github.io/2018/05/25/BFPRT/</id>
    <published>2018-05-25T03:34:00.000Z</published>
    <updated>2018-07-20T11:38:10.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-BFPRT算法"><a href="#4-BFPRT算法" class="headerlink" title="4.BFPRT算法"></a>4.BFPRT算法</h1><p>解决问题：求一个数组中第k小或第k大的数。复杂度O(n)。<br>　　算法流程：<br>  a)    将数组每5个划成一组；<br>b)    每个组内排序，分别取每一组中的中位数组成一个新的数组；<br>c)    将新的数组进行排序，取其中的中位数a作为参考值；<br>d)    取a对原数组进行比较，把小于a的数放在左边，等于a的放中间，大于a的放右边，看a是否是第k小的数，若不是再从左边或右边重复同一过程。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMinKthByBFPRT</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copyArr = arr.slice();</span><br><span class="line">    <span class="keyword">return</span> select(copyArr, <span class="number">0</span>, copyArr.length - <span class="number">1</span>, k - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求出arr数组中从begin到end之间的子数组中第i小上的数</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param begin</span></span><br><span class="line"><span class="comment"> * @param end</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> * @returns &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">arr, begin, end, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin === end) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[begin];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pivot = medianOfMedians(arr, begin, end);</span><br><span class="line">    <span class="keyword">var</span> pivotRange = partition(arr, begin, end, pivot);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= pivotRange[<span class="number">0</span>] &amp;&amp; i &lt;= pivotRange[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; pivotRange[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> select(arr, begin, pivotRange[<span class="number">0</span>] - <span class="number">1</span>, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> select(arr, pivotRange[<span class="number">1</span>] + <span class="number">1</span>, end, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给数组分组，并求出每组数组中位数，返回中位数组成数组中的中位数</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param begin 原始数组中子数组开始位置</span></span><br><span class="line"><span class="comment"> * @param end  原始数组中子数组结束位置</span></span><br><span class="line"><span class="comment"> * @returns &#123;*&#125;  划分所用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">medianOfMedians</span>(<span class="params">arr, begin, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> mArr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.ceil(num / <span class="number">5</span>)); <span class="comment">//中位数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> beginI = begin + i * <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">var</span> endI = beginI + <span class="number">4</span>;</span><br><span class="line">        mArr[i] = getMedian(arr, beginI, <span class="built_in">Math</span>.min(end, endI));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> select(mArr, <span class="number">0</span>, mArr.length - <span class="number">1</span>, <span class="built_in">parseInt</span>(mArr.length / <span class="number">2</span>));<span class="comment">//求中位数数组的上中位数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, begin, end, pivotValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> small = begin - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> cur = begin;</span><br><span class="line">    <span class="keyword">var</span> big = end + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur !== big) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; pivotValue) &#123;</span><br><span class="line">            swap(arr, ++small, cur++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; pivotValue) &#123;</span><br><span class="line">            swap(arr, cur, --big)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> range = [];</span><br><span class="line">        range[<span class="number">0</span>] = small + <span class="number">1</span>;</span><br><span class="line">        range[<span class="number">1</span>] = big - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> range;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到五位数组的中位数</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param begin</span></span><br><span class="line"><span class="comment"> * @param end</span></span><br><span class="line"><span class="comment"> * @returns &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMedian</span>(<span class="params">arr, begin, end</span>) </span>&#123;</span><br><span class="line">    insertSort(arr, begin, end);</span><br><span class="line">    <span class="keyword">var</span> sum = end + begin;</span><br><span class="line">    <span class="keyword">var</span> mid = <span class="built_in">Math</span>.ceil(sum / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[mid];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param begin</span></span><br><span class="line"><span class="comment"> * @param end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr, begin, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = begin - <span class="number">1</span>; i &lt; end + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j !== begin; j--) &#123;<span class="comment">//依次将第j个插入到前面排序好的j-1数组中</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getMinKthByBFPRT([<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">3</span>)); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;4-BFPRT算法&quot;&gt;&lt;a href=&quot;#4-BFPRT算法&quot; class=&quot;headerlink&quot; title=&quot;4.BFPRT算法&quot;&gt;&lt;/a&gt;4.BFPRT算法&lt;/h1&gt;&lt;p&gt;解决问题：求一个数组中第k小或第k大的数。复杂度O(n)。&lt;br&gt;　　算法流程：&lt;b
      
    
    </summary>
    
      <category term="算法" scheme="https://waldosia.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://waldosia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="javascript" scheme="https://waldosia.github.io/tags/javascript/"/>
    
      <category term="BFPRT" scheme="https://waldosia.github.io/tags/BFPRT/"/>
    
  </entry>
  
  <entry>
    <title>Manacher算法之js实现</title>
    <link href="https://waldosia.github.io/2018/05/13/Manacher/"/>
    <id>https://waldosia.github.io/2018/05/13/Manacher/</id>
    <published>2018-05-13T14:23:00.000Z</published>
    <updated>2018-07-20T11:38:57.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-Manacher算法"><a href="#3-Manacher算法" class="headerlink" title="3.Manacher算法"></a>3.Manacher算法</h1><h2 id="3-1-manacher算法"><a href="#3-1-manacher算法" class="headerlink" title="3.1.    manacher算法"></a>3.1.    manacher算法</h2><p>给定一个字符串，找出其最长回文子串（子串在原字符串必须连续，子序列不一定要连续）.<br>例如：<br>s=”1234”，最长回文长度为 1；<br>s=”12321”，最长回文长度为 5；<br>s=”12332”，最长回文长度为 4，即2332。<br>笨办法：遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为O(n^2)。<br><b>Manacher算法</b>：时间复杂度O(n)<br>a)    因为存在奇回文和偶回文，所以在字符串首尾以及中间插入特殊字符。偶回文则以特殊字符为中心，便可以一起处理。<br>例如：12332加入特殊字符后变成#1#2#3#2#3#，中心为红色的#号。<br>b)    定义一个辅助数组pArr，数组的第i点的值表示以i点为中心时的最大回文半径。<br>例如：</p><p><table><tr><th>str</th><td>#</td><td>1</td><td>#</td><td>2</td><td>#</td><td>3</td><td>#</td><td>3</td><td>#</td><td>2</td><td>#</td></tr><tr><th>pArr</th><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td><td>2</td><td>5</td><td>2</td><td>1</td><td>2</td><td>1</td></tr></table><br>无回文时，以自己为半径，所以半径为1。可以看出pArr-1为该点的最大回文长度。<br>c)    之后就是计算pArr数组的方法。首先以R记录到i点之前所有回文的右边界，index为该右边界所在回文的中心点，则左边界L=index-R。计算i点为半径的最大回文半径时，分四种情况：<br>1）    i点在R的外部，则计算以i点为中心两边的回文长度；<br>2）    i在R的内部，且i关于index的对称点i’的回文左边界在L内部，则i的最大回文半径和i’相等。<br>3）    i在R的内部，且i关于index的对称点i’的回文左边界在L外部，则i的最大回文半径为R-i。<br>4）    i在R的内部，且i关于index的对称点i’的回文左边界与L相等，则i的最小回文半径为R-i，直接比较最小半径以外的数值即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 往字符串中每个字符中间插入#号</span></span><br><span class="line"><span class="comment"> * @param str</span></span><br><span class="line"><span class="comment"> * @returns &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">manacherString</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = str.split(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(str.length * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i !== res.length; i++) &#123;</span><br><span class="line">    res[i] = (i &amp; <span class="number">1</span>) === <span class="number">0</span> ? <span class="string">'#'</span> : arr[index++];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确定字符串中最大回文长度</span></span><br><span class="line"><span class="comment"> * @param str</span></span><br><span class="line"><span class="comment"> * @returns &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxLcpsLength</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> arr = manacherString(str);  </span><br><span class="line">  <span class="keyword">var</span> pArr = <span class="keyword">new</span> <span class="built_in">Array</span>(arr.length); <span class="comment">//每一点的最大回文半径</span></span><br><span class="line">  <span class="comment">//最右回文的中心点位置</span></span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//所有回文的最右边界</span></span><br><span class="line">  <span class="keyword">var</span> R = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//最大回文半径</span></span><br><span class="line">  <span class="keyword">var</span> max = <span class="built_in">Number</span>.MIN_VALUE;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i !== arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//确定i是否在最右回文半径中，若i在半径中，则i的半径至少是对称点半径与i点右边到最大回文半径的最小值；</span></span><br><span class="line">    pArr[i] = R &gt; i ? <span class="built_in">Math</span>.min(pArr[<span class="number">2</span> * index - i], R - i) : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//确认i点回文长度未超过字符串长度，</span></span><br><span class="line">    <span class="keyword">while</span> (i + pArr[i] &lt; arr.length &amp;&amp; i - pArr[i] &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">//确定i点回文半径两边的点是否相等</span></span><br><span class="line">      <span class="keyword">if</span> (arr[i + pArr[i]] === arr[i - pArr[i]]) &#123;</span><br><span class="line">        <span class="comment">//相等时i点回文半径加1，继续循环</span></span><br><span class="line">        pArr[i]++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不相等时退出循环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改最大回文半径时的右边界,与最大回文半径的中心点</span></span><br><span class="line">    <span class="keyword">if</span> (i + pArr[i] &gt; R) &#123;</span><br><span class="line">      R = i + pArr[i];</span><br><span class="line">      index = i;</span><br><span class="line">    &#125;</span><br><span class="line">   max = <span class="built_in">Math</span>.max(max, pArr[i]);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">return</span> max<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(maxLcpsLength(<span class="string">'a123321bcd'</span>));</span><br></pre></td></tr></table></figure></p><h2 id="3-2-Manacher算法扩展题目"><a href="#3-2-Manacher算法扩展题目" class="headerlink" title="3.2.    Manacher算法扩展题目"></a>3.2.    Manacher算法扩展题目</h2><p>　　给定一个字符串str1， 只能往str1的后面添加字符变成str2， 要求str2整体都是回文串且最短。<br>  举例：str1 = ABC12321, 返回ABC12321CBA.<br>  解法：重复manacher算法，当回文最右边界R到达str1的最后一位时，结束manacher算法，然后将str中L外部的子串逆序放在str1后面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-Manacher算法&quot;&gt;&lt;a href=&quot;#3-Manacher算法&quot; class=&quot;headerlink&quot; title=&quot;3.Manacher算法&quot;&gt;&lt;/a&gt;3.Manacher算法&lt;/h1&gt;&lt;h2 id=&quot;3-1-manacher算法&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="算法" scheme="https://waldosia.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://waldosia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="javascript" scheme="https://waldosia.github.io/tags/javascript/"/>
    
      <category term="js" scheme="https://waldosia.github.io/tags/js/"/>
    
      <category term="manacher" scheme="https://waldosia.github.io/tags/manacher/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法之js实现</title>
    <link href="https://waldosia.github.io/2018/05/13/KMP/"/>
    <id>https://waldosia.github.io/2018/05/13/KMP/</id>
    <published>2018-05-13T13:55:00.000Z</published>
    <updated>2018-07-20T11:38:47.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-KMP算法"><a href="#2-KMP算法" class="headerlink" title="2.KMP算法"></a>2.KMP算法</h1><h2 id="2-1-KMP算法"><a href="#2-1-KMP算法" class="headerlink" title="2.1.    KMP算法"></a>2.1.    KMP算法</h2><p>　　求解问题：有两个字符串str1和str2，寻找str1是否包含str2，并找出包含的起始位置。如str1=12341234d，str2=1234d，则包含的起始位置为4。<br>　　笨办法：假设str2的字符串长度为m，从str1的0位置开始，选取以该位置开头的长度为m的子字符串与str2匹配，若匹配成功，返回该位置，若匹配不成功，则从str1的下一个位置开始继续匹配，直到匹配结束。<br>　　<b>KMP算法</b>：（时间复杂度O(n)）<br>  a)    利用str2建立长度为m的next数组，表示str2对应位置前面字符串的最大前缀和最大后缀的匹配。<br> 　建立规则：取str2的第i个字符，看str2(i)前面的子字符串，其中前缀与后缀相等时的最大长度。其中前缀不能包括子字符串的最后一位，后缀不能包括子字符串的第一位。Next数组以-1和0开头。<br>  举例：str2=12341234d，<br> <table><tbody><tr><th>前后缀长度</th><th>前缀</th><th>后缀</th></tr><tr><td>1</td><td>1</td><td>4</td></tr><tr><td>2</td><td>12</td><td>34</td></tr><tr><td>3</td><td>123</td><td>234</td></tr><tr><td bgcolor="SteelBlue">4</td><td bgcolor="SteelBlue">1234</td><td bgcolor="SteelBlue">1234</td></tr><tr><td>5</td><td>12341</td><td>41234</td></tr><tr><td>6</td><td>123412</td><td>231234</td></tr></tbody></table></p><p><tr><td>7</td><td>1234123</td><td>2341234</td></tr><br>　由上表可知，当长度为4时，前缀与后缀相等，为1234。故该点的next数值为4。<br> b)    建立好str2的next数组时，还是以str1的0位置开始与str2配对，假设在以str1的j位置开始与str2配对时，直到m位置未配对成功，此时str2的m位置最大前后缀为下图橙色区域，橙色区域位置字符串均相等，则下次配对str2直接右移至下图位置，可直接比较C与A是否相等。<br> <img src="/img/kmp.jpg"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KMP算法求解str1是否包含str2，若包含，返回包含的起始位置，若不包含，返回-1；</span></span><br><span class="line"><span class="comment"> * @param str1</span></span><br><span class="line"><span class="comment"> * @param str2</span></span><br><span class="line"><span class="comment"> * @returns &#123;number&#125;</span></span><br><span class="line"><span class="comment"> * @constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">KMP</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (str1.length &lt; <span class="number">1</span> || str2.length &lt; <span class="number">1</span> || str1.length &lt; str2.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> arr1 = str1.split(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">var</span> arr2 = str2.split(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">var</span> i1 = <span class="number">0</span>; <span class="comment">//str1配对索引</span></span><br><span class="line">  <span class="keyword">var</span> i2 = <span class="number">0</span>; <span class="comment">//str2配对索引</span></span><br><span class="line">  <span class="keyword">var</span> next = getNextArray(arr2);</span><br><span class="line">  <span class="keyword">while</span> (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123;</span><br><span class="line">     <span class="comment">//i1字符与i2字符配对成功，继续配对下一个</span></span><br><span class="line">     <span class="keyword">if</span> (arr1[i1] === arr2[i2]) &#123;</span><br><span class="line">        i1++;</span><br><span class="line">        i2++;</span><br><span class="line">     <span class="comment">//未配对成功，next数组中只有0位置为-1，所以配对str1下一位</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[i2] === <span class="number">-1</span>) &#123;</span><br><span class="line">        i1++;</span><br><span class="line">     <span class="comment">//未配对成功，str2的最大前缀下一个与i1配对</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i2 = next[i2];</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> i2 === str2.length ? i1 - i2 : <span class="number">-1</span>;<span class="comment">//i2到头相当于配对成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求解啊arr2的next数组</span></span><br><span class="line"><span class="comment"> * @param arr2</span></span><br><span class="line"><span class="comment"> * @returns &#123;Array&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNextArray</span>(<span class="params">arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr2.length === <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> [<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> next = <span class="keyword">new</span> <span class="built_in">Array</span>(arr2.length);</span><br><span class="line">  next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> pos = <span class="number">2</span>; <span class="comment">//str2索引</span></span><br><span class="line">  <span class="keyword">var</span> cn = <span class="number">0</span>;<span class="comment">//比较位置为前一个数的next值</span></span><br><span class="line">  <span class="keyword">while</span> (pos &lt; arr2.length) &#123;</span><br><span class="line">     <span class="comment">//判断前一个数与比较位置最大前缀的后一个数是否相等</span></span><br><span class="line">     <span class="keyword">if</span> (arr2[pos - <span class="number">1</span>] === arr2[cn]) &#123; </span><br><span class="line">       <span class="comment">//相等时该点的next数值则为某个数的next数值+1，继续循环下一个数</span></span><br><span class="line">       next[pos++] = ++cn; </span><br><span class="line">     <span class="comment">//不相等时，取cn位置做为比较位置</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       cn = next[cn];</span><br><span class="line">     <span class="comment">//cn&lt;0时，比较位置为0位置，则该点next值为0</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       next[pos++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(KMP(<span class="string">'12341234a'</span>, <span class="string">'1234a'</span>));<span class="comment">//4</span></span><br></pre></td></tr></table></figure></p><h2 id="2-2-KMP算法扩展题目一"><a href="#2-2-KMP算法扩展题目一" class="headerlink" title="2.2.    KMP算法扩展题目一"></a>2.2.    KMP算法扩展题目一</h2><p>　　给定一个字符串str1，只能往str1的后面添加字符变成str2。<br>  要求1：str2必须包含两个str1，两个str1可以有重合，但是不能以同一个位置开头。<br>  要求2：str2尽量短。<br>  要求返回str2。<br>  举例：<br>str1=123，str2=123123，包含两个str1，且不以相同位置开头，且str2最短。<br>str1=123123，str2=123123123，包含两个str1，且不以相同位置开头，且str2最短。str1=111，str2=1111，包含两个str1，且不以相同位置开头，且str2最短。<br><b>解法</b>：求str1最后一个字符后一个位置的next数值，然后把str1除去最大前缀的剩下字符串放在str1后面就形成str2。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个字符串str1，只能往str1的后面添加字符变成str2。</span></span><br><span class="line"><span class="comment"> * 要求1：str2必须包含两个str1，两个str1可以有重合，但是不能以同一个位置开头。</span></span><br><span class="line"><span class="comment"> * 要求2：str2尽量短。</span></span><br><span class="line"><span class="comment"> * 要求返回str2。</span></span><br><span class="line"><span class="comment"> * @param str1</span></span><br><span class="line"><span class="comment"> * @returns &#123;string&#125; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kmpQuestion1</span>(<span class="params">str1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> next = <span class="keyword">new</span> <span class="built_in">Array</span>(str1.length+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> pos = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> cn = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> arr1 = str1.split(<span class="string">''</span>);</span><br><span class="line">  next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//求next数组</span></span><br><span class="line">  <span class="keyword">while</span>(pos&lt;arr1.length+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr1[pos<span class="number">-1</span>]===arr1[cn])&#123;</span><br><span class="line">      next[pos++]=++cn;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cn&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      cn=next[cn];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      next[pos++]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> str1+str1.substring(cn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kmpQuestion1(<span class="string">'123123'</span>));<span class="comment">//123123123</span></span><br></pre></td></tr></table></figure></p><h2 id="2-3-KMP算法扩展题目二"><a href="#2-3-KMP算法扩展题目二" class="headerlink" title="2.3.    KMP算法扩展题目二"></a>2.3.    KMP算法扩展题目二</h2><p>　　给定两个二叉树T1和T2， 返回T1的某个子树结构是否与T2的结构相等。<br>  <b>解法</b>：将两个二叉树分别序列化，然后判断T1字符串中是否包含T2字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-KMP算法&quot;&gt;&lt;a href=&quot;#2-KMP算法&quot; class=&quot;headerlink&quot; title=&quot;2.KMP算法&quot;&gt;&lt;/a&gt;2.KMP算法&lt;/h1&gt;&lt;h2 id=&quot;2-1-KMP算法&quot;&gt;&lt;a href=&quot;#2-1-KMP算法&quot; class=&quot;header
      
    
    </summary>
    
      <category term="算法" scheme="https://waldosia.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://waldosia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="js" scheme="https://waldosia.github.io/tags/js/"/>
    
      <category term="KMP" scheme="https://waldosia.github.io/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法之js实现</title>
    <link href="https://waldosia.github.io/2018/05/03/sortAlgorithm/"/>
    <id>https://waldosia.github.io/2018/05/03/sortAlgorithm/</id>
    <published>2018-05-03T14:33:00.000Z</published>
    <updated>2018-07-20T11:38:29.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1算法复杂度"><a href="#1算法复杂度" class="headerlink" title="1算法复杂度"></a>1算法复杂度</h1><h2 id="1-1认识时间复杂度"><a href="#1-1认识时间复杂度" class="headerlink" title="1.1认识时间复杂度"></a>1.1认识时间复杂度</h2><p>　　时间复杂度为一个算法流程中，常数操作数量的指标，这个指标叫做O，big O。具体为，如果常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项系数之后，剩下的部分记为f(N)，那么该算法的时间复杂度为O(f(N)).　</p><h2 id="1-2冒泡排序"><a href="#1-2冒泡排序" class="headerlink" title="1.2冒泡排序"></a>1.2冒泡排序</h2><p>　　即大数依次往下沉。需要操作N(N-1)/2次。时间复杂度O(N^2),额外空间复杂度O(1) （与数组长度无关），实现可以做到稳定性（是指一个数组在排完序后值相等的数顺序不会发生变化）。异或——无进位相加；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> e=arr.length<span class="number">-1</span>;e&gt;<span class="number">0</span>;e--)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">            swap(arr,i,i+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line">   <span class="comment">/*只有在i与j不相等时才能用，且arr内值均为整数，交换两数</span></span><br><span class="line"><span class="comment">   arr[i]=arr[i]^arr[j];</span></span><br><span class="line"><span class="comment">   arr[j]=arr[i]^arr[j];</span></span><br><span class="line"><span class="comment">   arr[i]=arr[i]^arr[j];*/</span></span><br><span class="line">   <span class="keyword">var</span> tmp=arr[i];</span><br><span class="line">   arr[j]=tmp;</span><br><span class="line">   arr[i]=arr[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>]));</span><br></pre></td></tr></table></figure></p><h2 id="1-3插入排序"><a href="#1-3插入排序" class="headerlink" title="1.3插入排序"></a>1.3插入排序</h2><p>　　——对比第n个数字与前n-1个排序好的数字，将第n个依次与第n-1、n-2…比较，若小于，则往上浮。将这第n个数字插入到左边排序好的数字其中，类似于扑克牌。时间复杂度O(N^2)，额外空间复杂度O(1)，实现可以做到稳定性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = arr.length ; i &lt; l; i++) &#123;<span class="comment">//i为要插入的数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">          swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(insertSort([<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>]));</span><br></pre></td></tr></table></figure></p><h2 id="1-4选择排序"><a href="#1-4选择排序" class="headerlink" title="1.4选择排序"></a>1.4选择排序</h2><p>　　——依次选出最小数放在第1,2,3…n个。时间复杂度O(N^2)，额外空间复杂度O(1)，实现可以做到稳定性。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectioSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> minIndex = i; <span class="comment">//最小数索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; l; j++) &#123;</span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(selectionSort([<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>]));</span><br></pre></td></tr></table></figure></p><h2 id="1-5随机快速排序"><a href="#1-5随机快速排序" class="headerlink" title="1.5随机快速排序"></a>1.5随机快速排序</h2><p>　　——随机选一个数，小于它的放左边，等于的放中间，大于的放右边。然后在两边继续随机选数排序。<br>时间复杂度O(n*logn)，额外空间复杂度O(logn)，常规实现做不到稳定性。<br>注意：<br>a)    快速排序中，额外空间复杂度最低为 O(logn)<br>b)    快速排序，可以做到稳定性的实现，但是非常难，不需要掌握<br>c)    荷兰国旗问题的实现，和快速排序中的改进。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomQuickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    arr=quickSort(arr,<span class="number">0</span>,arr.length<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, l, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        swap(arr, l + <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * (r - l + <span class="number">1</span>)), r);<span class="comment">//随机选择一个数放在最后</span></span><br><span class="line">        <span class="keyword">var</span> p = partition(arr, l, r);</span><br><span class="line">        quickSort(arr, l, p[<span class="number">0</span>]); <span class="comment">//小于区排序</span></span><br><span class="line">        quickSort(arr, p[<span class="number">1</span>] + <span class="number">1</span>, r); <span class="comment">//大于区排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, l, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> less = l - <span class="number">1</span>;  <span class="comment">//小于区域最后一个</span></span><br><span class="line">    <span class="keyword">var</span> more = r;    <span class="comment">//大于区域最前面一个</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;<span class="comment">//小于随机数时，该数与小于区边界后一个交换</span></span><br><span class="line">            swap(arr, ++less, l++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; arr[r]) &#123;<span class="comment">//大于随机数时，该数与大于区前一个数交换</span></span><br><span class="line">            swap(arr, --more, l);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//等于时跳下一个</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, more, r); <span class="comment">//将选择的随机数放到大于区第一个</span></span><br><span class="line">    <span class="keyword">return</span> [less, more]; <span class="comment">//返回小于区和大于区的边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(randomQuickSort([<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>]));</span><br></pre></td></tr></table></figure></p><h2 id="1-6归并排序"><a href="#1-6归并排序" class="headerlink" title="1.6归并排序"></a>1.6归并排序</h2><p>——大数组依次对半拆分至单个数再往上合并。<br>时间复杂度 ，额外空间复杂度 ，实现可以做到稳定性。<br>注意：<br>a)    库函数中排序的实现是综合排序，比如插入+快速；比如为了稳定性，排序算法往往是快排+堆排序；<br>b)    归并排序和快速排序，都一定存在非递归的实现；<br>c)    归并排序，存在额外空间复杂度O(1)的实现（内部缓存法），但是非常难，你不需要掌握；<br>d)    归并排序的扩展，小和问题，逆序对。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bigMergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr, l, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l === r) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取中位数，如果直接用(l+r)/2可能会溢出，而右移相当于除2，而且比除法速度快。</span></span><br><span class="line">    <span class="keyword">var</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    mergeSort(arr, l, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    merge(arr, l, mid, r); <span class="comment">//排序好的两半合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr, l, m, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Array</span>(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>, p1 = l, p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        tmp[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">        tmp[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">        tmp[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">        arr[l + i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bigMergeSort([<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>]));</span><br></pre></td></tr></table></figure></p><p>小和问题：<br>在随机元素，随机数组大小的数组中，找出左边比右边元素小的所有元素之和。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">smallSum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr, l, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l === r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取中位数，如果直接用(l+r)/2可能会溢出，而右移相当于除2，而且比除法速度快。</span></span><br><span class="line">    <span class="keyword">var</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mergeSort(arr, l, mid) + mergeSort(arr, mid + <span class="number">1</span>, r) + merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr, l, m, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Array</span>(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>, p1 = l, p2 = m + <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>; <span class="comment">//提取小和</span></span><br><span class="line">        tmp[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">        tmp[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">        tmp[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">        arr[l + i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(smallSum([<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>]));</span><br></pre></td></tr></table></figure></p><h2 id="1-7堆排序"><a href="#1-7堆排序" class="headerlink" title="1.7堆排序"></a>1.7堆排序</h2><p>时间复杂度 ，额外空间复杂度 ，实现做不到稳定性。<br>关键步骤：heapInsert，heapify，堆的扩大和缩小操作。<br>注意：<br>a)    堆排序中，建立堆的操作为O(n)；<br>b)    堆排序的核心数据结构：堆，也可以说是优先级队列；<br>堆：完全二叉树结构<br>大根堆：任何一个节点都是下面整棵树的最大的值。<br>一个节点i，父节点为(i-1)/2，左孩子为2<em>i+1，右孩子为2</em>i+2<br>步骤：先建大根堆，然后堆顶最大值与堆尾互换，新的堆顶下沉，继续建大根堆；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">        heapInsert(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> size=arr.length;</span><br><span class="line">    swap(arr,<span class="number">0</span>,--size);</span><br><span class="line">    <span class="keyword">while</span> (size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        heapify(arr,<span class="number">0</span>,size);</span><br><span class="line">        swap(arr,<span class="number">0</span>,--size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapInsert</span>(<span class="params">arr, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根顶下沉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, index, size</span>) </span>&#123;<span class="comment">//下沉操作</span></span><br><span class="line">    <span class="keyword">var</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size) &#123;<span class="comment">//是否有后代</span></span><br><span class="line">        <span class="comment">//找出较大孩子序号</span></span><br><span class="line">        <span class="keyword">var</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;<span class="comment">//我以及我孩子中的最大值序号</span></span><br><span class="line">        <span class="keyword">if</span> (largest === index) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, largest, index);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//互换函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(heapSort([<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>]));</span><br></pre></td></tr></table></figure></p><h2 id="1-8桶排序与基数排序"><a href="#1-8桶排序与基数排序" class="headerlink" title="1.8桶排序与基数排序"></a>1.8桶排序与基数排序</h2><p>时间复杂度O(n)，额外空间复杂度O(n)，实现做到稳定性。<br>注意:<br>a)    桶排序的扩展，排序后的最大相邻数差值问题<br>　解法：数组长度为N，准备N+1个桶，将数组的最大值减最小值的范围均分N+1份，每一份代表桶的范围，依次把数组内的数放入桶内部，求出非空桶内的最小值与前一个非空桶的最大值的差值，其中最大的就为最大相邻数差值。例如数组[1,3,5,11]，最大值减最小值范围是10，则5个桶的范围是[1~3,3~5,5~7,7~9,9~11]。<br>b)    非基于比较的排序，对数据的位数和范围有限制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxGap</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="built_in">Number</span>.MIN_VALUE;</span><br><span class="line">    <span class="keyword">var</span> min = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; len; n++) &#123;</span><br><span class="line">       min = <span class="built_in">Math</span>.min(min, arr[n]);</span><br><span class="line">       max = <span class="built_in">Math</span>.max(max, arr[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max === min) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> hasNum = <span class="keyword">new</span> <span class="built_in">Array</span>(len + <span class="number">1</span>);<span class="comment">//桶内是否有数数组</span></span><br><span class="line">    <span class="keyword">var</span> maxs = <span class="keyword">new</span> <span class="built_in">Array</span>(len + <span class="number">1</span>);<span class="comment">//桶内最大值数组</span></span><br><span class="line">    <span class="keyword">var</span> mins = <span class="keyword">new</span> <span class="built_in">Array</span>(len + <span class="number">1</span>);<span class="comment">//桶内最小值数组</span></span><br><span class="line">    <span class="keyword">var</span> bid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">       bid = bucket(arr[i], len, min, max);</span><br><span class="line">       <span class="comment">//更新桶信息</span></span><br><span class="line">       mins[bid] = hasNum[bid] ? <span class="built_in">Math</span>.min(mins[bid], arr[i]) : arr[i];</span><br><span class="line">       maxs[bid] = hasNum[bid] ? <span class="built_in">Math</span>.max(maxs[bid], arr[i]) : arr[i];</span><br><span class="line">       hasNum[bid] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> lastMax = maxs[<span class="number">0</span>]; <span class="comment">//上一个桶的最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= len; j++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (hasNum[j]) &#123;</span><br><span class="line">          res = <span class="built_in">Math</span>.max(res, mins[j] - lastMax); <span class="comment">//取非空桶与上一个桶的差值中的最大值。</span></span><br><span class="line">            lastMax = maxs[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数字进第几号桶</span></span><br><span class="line"><span class="comment"> * @param num</span></span><br><span class="line"><span class="comment"> * @param len</span></span><br><span class="line"><span class="comment"> * @param min</span></span><br><span class="line"><span class="comment"> * @param max</span></span><br><span class="line"><span class="comment"> * @returns &#123;Number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucket</span>(<span class="params">num, len, min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>((num - min) * len / (max - min));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(maxGap([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1算法复杂度&quot;&gt;&lt;a href=&quot;#1算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;1算法复杂度&quot;&gt;&lt;/a&gt;1算法复杂度&lt;/h1&gt;&lt;h2 id=&quot;1-1认识时间复杂度&quot;&gt;&lt;a href=&quot;#1-1认识时间复杂度&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="算法" scheme="https://waldosia.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://waldosia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="javascript" scheme="https://waldosia.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="https://waldosia.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://waldosia.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="https://waldosia.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="https://waldosia.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="选择排序" scheme="https://waldosia.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://waldosia.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="https://waldosia.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://waldosia.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>千位分隔符js正则实现</title>
    <link href="https://waldosia.github.io/2018/04/10/ThousandCharacter/"/>
    <id>https://waldosia.github.io/2018/04/10/ThousandCharacter/</id>
    <published>2018-04-10T04:04:00.000Z</published>
    <updated>2018-08-05T08:20:42.765Z</updated>
    
    <content type="html"><![CDATA[<p>首先考虑最简单的情况–整数，如123456789，只需考虑字符串从最后一位往前考虑存在3n个数字，且不包括第一位字符，代码如下<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addComma</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num &amp;&amp; num.toString()</span><br><span class="line">.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">'$1,'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(addComma(<span class="number">1234567890</span>));<span class="comment">//1,234,567,890</span></span><br></pre></td></tr></table></figure></p><p>　　其中<code>(/d)</code>保证3n个字符前存在一个数字，并且可以捕获到该数字，则在该数字后面加上，即可。<code>(?=exp)</code>代表匹配exp前面的位置，所以捕获到的数字与<code>(/d)</code>相同。<code>exp+</code>代表匹配exp一次或多次。<code>$/</code>代表匹配字符串的结束。<br>　　然后考虑更复杂一点的情况–小数，如1234567890.123456，这时需要取到数字的起始位到小数点之间的部分，利用<code>^-?\d+</code>实现，代码如下<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addComma</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num &amp;&amp; num.toString()</span><br><span class="line">.replace(<span class="regexp">/^-?\d+/</span>,<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">'$1,'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(addComma(<span class="number">1234567890.123456</span>));<span class="comment">//1,234,567,890.123456</span></span><br></pre></td></tr></table></figure></p><p>其中<code>\^</code>匹配字符串的开头。<code>-?</code>代表匹配-号0次或一次。<br>由此，千位分割符即实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先考虑最简单的情况–整数，如123456789，只需考虑字符串从最后一位往前考虑存在3n个数字，且不包括第一位字符，代码如下&lt;br&gt;  &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://waldosia.github.io/categories/JavaScript/"/>
    
    
      <category term="js" scheme="https://waldosia.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ES6-第６章-Symbol和Symbol属性</title>
    <link href="https://waldosia.github.io/2018/03/28/es6_6/"/>
    <id>https://waldosia.github.io/2018/03/28/es6_6/</id>
    <published>2018-03-28T09:24:00.000Z</published>
    <updated>2018-08-05T09:36:25.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="6-Symbol和Symbol属性"><a href="#6-Symbol和Symbol属性" class="headerlink" title="6.Symbol和Symbol属性"></a>6.Symbol和Symbol属性</h3><p>　　Symbol是JavaScript中一个新的原始类型，用于创建必须通过Symbol才能使用的属性。尽管这些属性不是完全私有的，但是他们比较难以被意外覆盖而改变。表示独一无二的值。可防止属性名冲突。</p><h4 id="6-1-创建Symbol"><a href="#6-1-创建Symbol" class="headerlink" title="6.1 创建Symbol"></a>6.1 创建Symbol</h4><p>　　所有原始类型值，除Symbol以外都有各自的字面量形式。可以通过全局的Symbol函数创建一个Symbol：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[firstName] = “Nicholas”;</span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]);   <span class="comment">//”Nicholas”</span></span><br></pre></td></tr></table></figure></p><p>　　在上面这段代码中，创建了一个名为firstName的Symbol，用它将一个新的属性赋值给person对象，每当你想访问这个属性时一定要用到最初定义的Symbol。记得要合理命名Symbol变量，这样可以轻松区分它所指代的内容。<br>注意，创建Symbol不要使用new调用。<br>　　Symbol函数接受一个可选参数，其可以让你添加一段文本描述即将常见的Symbol，这段描述不可用于属性访问，只能方便阅读和调试。描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法可以读取该属性。<br>　　Symbol使用typeof辨识，返回”symbol”。</p><h4 id="6-2-Symbol的使用方法"><a href="#6-2-Symbol的使用方法" class="headerlink" title="6.2 Symbol的使用方法"></a>6.2 Symbol的使用方法</h4><p>　　Symbol可用于可计算对象字面量属性名、Object.defineProperty()方法和Object.defineProperties()方法的调用过程中。</p><h4 id="6-3-Symbol共享体系"><a href="#6-3-Symbol共享体系" class="headerlink" title="6.3 Symbol共享体系"></a>6.3 Symbol共享体系</h4><p>　　有时我们可能希望在不同的代码中共享同一个Symbol，例如，在你的应用中有种不同的对象类型，但是你希望它们使用同一个Symbol属性来表示一个独特的标识符。一般而言，在很大的代码库中或跨文件追踪Symbol非常困难而且容易出错，处于这些原因，ES6提供了一个可以随时访问的全局Symbol注册表。<br>　　如果想创建一个可共享的Symbol，要使用Symbol.for()方法。传入即将要创建的Symbol的字符串标识符（键-作为Symbol唯一的标识），同时作为Symbol的描述。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(“uid”);</span><br></pre></td></tr></table></figure></p><p>　　该方法首先在全局Symbol注册表中搜索键为”uid”的Symbol是否存在，存在后直接返回已有的Symbol，不存在则创建一个新的Symbol并返回。<br>Symbol.ketFor()方法：在Symbol全局注册表中检索与Symbol有关的键，返回创建时传入的标识符（键）。不存在时返回undefined。</p><h4 id="6-4-Symbol与类型强制转换"><a href="#6-4-Symbol与类型强制转换" class="headerlink" title="6.4 Symbol与类型强制转换"></a>6.4 Symbol与类型强制转换</h4><p>　　console.log()输出Symbol时，会调用Symbol的String()方法，String()会调用Symbol的toString()方法，返回字符串类型的Symbol描述里的内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(“uid”);</span><br><span class="line"><span class="built_in">console</span>.log(uid);  <span class="comment">//”Symbol(uid)”</span></span><br></pre></td></tr></table></figure></p><p>　　但是不能将Symbol与一个字符串拼接，也不能进行算术运算，也就是Symbol无法强制转换为数值与字符串。</p><h4 id="6-5-Symbol属性检索"><a href="#6-5-Symbol属性检索" class="headerlink" title="6.5 Symbol属性检索"></a>6.5 Symbol属性检索</h4><p>　　Object.keys()—返回所有可枚举的属性名；<br>　　Object.getOwnPropertyNames()—不考虑属性的可枚举性一律返回；<br>　　上面两个方法都不支持Symbol属性。<br>　　Object.getOwnPropertySymbols()—检索对象中的所有Symbol属性，返回一个包含所有Symbol自有属性的数组。</p><h4 id="6-6-通过well-known-Symbol暴露内部操作"><a href="#6-6-通过well-known-Symbol暴露内部操作" class="headerlink" title="6.6 通过well-known Symbol暴露内部操作"></a>6.6 通过well-known Symbol暴露内部操作</h4><p>　　ES5的一个中心主旨是将JavaScript中的一些“神奇”的部分暴露出来，并详尽定义了这些开发者们在当时模拟不了的功能。ES6延续了这个传统，新标准中主要通过在原型链上定义与　Symbol相关的属性来暴露更多语言内部逻辑。<br>　　ES6开放了以前JavaScript中常见的内部操作，并通过预定义一些well-known Symbol来表示。每一个这类Symbol都是Symbol对象的一个属性。这些well-known Symbol包括：</p><ul><li>Symbol.hasInstance：一个在执行instanceof时调用的内部方法，用于检测对象的继承信息。</li><li>Symbol.isConcatSpreadable：一个布尔值，用于当传递一个集合作为Array.prototype.concat()方法的参数时，是否应该将集合内的元素规整到同一层级。</li><li>Symbol.iterator：一个返回迭代器的方法</li><li>Symbol.match：一个在调用String.prototype.match()方法时调用的方法，用于比较字符串。</li><li>Symbol.replace：一个在调用String.prototype.replace()方法时调用的方法，用于替换字符串的子串。</li><li>Symbol.search：一个在调用String.prototype.search()方法时调用的方法，用于在字符串中定位子串。</li><li>Symbol.species：用于创建派生类的构造函数。</li><li>Symbol.split：一个在调用String.prototype.toString()方法时使用的字符串，用于分割字符串</li><li>Symbol.toPrimitive：一个返回对象原始值的方法。 </li><li>Symbol.toStringTag：一个在调用Object.prototype.toString()方法时使用的字符串，用于创建对象描述。</li><li>Symbol.unscopables：一个定义了一些不可被with语句引用的对象属性名称的对象集合。<br>　　重写一个由well-known Symbol定义的方法，会导致对象内部的默认行为被改变，从而一个普通对象会变成一个奇异对象。但实际上其不会对你的代码产生任何影响，只是在规范中描述对象的方式改变了。<h5 id="Symbol-hasInstance方法"><a href="#Symbol-hasInstance方法" class="headerlink" title="Symbol.hasInstance方法"></a>Symbol.hasInstance方法</h5>　　该方法用于确定对象是否为函数的实例。该方法在Function.prototype中定义，所以所有函数都继承了instanceof属性的默认行为。该方法被定义为不可写，不可配置并且不可枚举。<br>　　Symbol.hasInstance方法只接受一个参数，即要检查的值。如果传入的是函数的实例，则返回true。<br><code>obj instanceof Array;</code>等价于 <code>Array[Symbol.hasInstance](obj);</code><br>　　本质上ES6只是将instanceof操作符重新定义为吃方法的简写语法。使用　Object.defineProperty()方法可改写一个不可写属性，若利用它改写了Symbol.hasInstance方法后，instanceof操作符运算返回的结果也会改变。<br>　　最好不要重写内建函数默认的Symbol.hasInstance属性。最好的做法是：只在必要情况下改写你自己声明的函数的Symbol.hasInstance属性<h5 id="Symbol-isConcatSpreadable方法"><a href="#Symbol-isConcatSpreadable方法" class="headerlink" title="Symbol.isConcatSpreadable方法"></a>Symbol.isConcatSpreadable方法</h5>　　concat()方法传入数组参数时，会自动将其分解为独立元素。现在可通过Symbol.isConcatSpreadable属性修改这个特性，该属性为一个布尔值，如果该属性为true，表示对象有length属性和数字键，故它的数值型属性值应该被独立添加到concat()调用的结果中。<br>　　与其他well-known Symbol不同，这个Symbol属性默认情况下不会出现在标准对象中，它只是一个可选属性，用于增强作用于特定对象类型的concat()方法中的功能，有效简化其默认特性。<br>　　也可以在派生数组子类中将Symbol.isConcatSpreadable设置为false，从未防止元素在调用concat()方法时被分解。<h5 id="Symbol-match、Symbol-replace、Symbol-rearch和Symbol-split属性"><a href="#Symbol-match、Symbol-replace、Symbol-rearch和Symbol-split属性" class="headerlink" title="Symbol.match、Symbol.replace、Symbol.rearch和Symbol.split属性"></a>Symbol.match、Symbol.replace、Symbol.rearch和Symbol.split属性</h5>　　字符串的match(regex),replace(regex,replacement),search(regex)和split(regex)这个四个方法无法使用开发者滴定仪的对象来替代正则表达式进行字符串匹配。<br>　　在ES6中，定义了上述4个方法对应的4个Symbol，将语言内建的RexExp对象的原生特性完全外包出来。<br>　　Symbol.match、Symbol.replace、Symbol.rearch和Symbol.split这4个属性表示match()、replace()、search()和split()方法中的第一个参数应该调用的正则表达式参数的方法，它们被定义在RegExp.prototype中，是字符串方法应该使用的默认实现。<br>　　我们可以类似于正则表达式的方法创建一个与字符串方法一起使用的对象，然后在上述4个方法中传入该对象，该对象的4个属性为：</li><li>Symbol.match：接受一个字符串类型的参数，如果匹配成功则返回匹配元素的数组，否则返回null</li><li>Symbol.replace：接受一个字符串类型的参数和一个替换用的字符串，最终仍然返回一个字符串</li><li>Symbol.rearch：接受一个字符串参数，如果匹配到内容，则返回数字的索引位置，否则返回-1</li><li>Symbol.split：接受一个字符串参数，根据匹配内容将字符串分解，并返回一个包含分解后片段的数组<br>　　如果可以在对象定义这些属性，可用该对象代替正则表达式，即使不使用正则表达式和以正则表达式为参的方法也可以在对象中实现模式匹配。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际上等价于/^.&#123;10&#125;$/</span></span><br><span class="line"><span class="keyword">let</span> hasLengthOf10 = &#123;</span><br><span class="line">　　[<span class="built_in">Symbol</span>.match]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value.length === <span class="number">10</span> ? [value.substring(<span class="number">0</span>,<span class="number">10</span>)] : <span class="literal">null</span>;</span><br><span class="line">&#125;,</span><br><span class="line">　　[<span class="built_in">Symbol</span>.replace]: <span class="function"><span class="keyword">function</span>(<span class="params">value, replacement</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value.length === <span class="number">10</span> ? replacement+value.substring(<span class="number">10</span>) : value;</span><br><span class="line">&#125;,</span><br><span class="line">　　[<span class="built_in">Symbol</span>.search]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value.length === <span class="number">10</span> ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;,</span><br><span class="line">　　[<span class="built_in">Symbol</span>.split]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value.length === <span class="number">10</span> ? [“”, “”] : [value];</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> message1 = “Hello World”,  </span><br><span class="line">  message2 = ”Hello John”;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> match1 = message1.match(hasLengthOf10),  <span class="comment">//null</span></span><br><span class="line">  match2 = message2.match(hasLengthOf10);  <span class="comment">//[“Hello John”]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> replace1 = message1.replace(hasLengthOf10),  <span class="comment">//”Hello World”</span></span><br><span class="line">  replace2 = message2.replace(hasLengthOf10);  <span class="comment">//”Hello John”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> search1 = message1.search(hasLengthOf10),  <span class="comment">//-1</span></span><br><span class="line">  search2 = message1.search(hasLengthOf10);  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> split1 = message1.split(hasLengthOf10),   <span class="comment">//[“Hello World”]</span></span><br><span class="line">  split1 = message1.split(hasLengthOf10);   <span class="comment">//[“”,””]</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h5><p>　　在JavaScript引擎中，当执行特定操作时，经常会尝试将对象转换到相应的原始值，例如，比较一个字符串和一个对象，如果使用==运算符，对象会在比较操作执行前被转换为一个原始值。到底使用哪个原始值以前是由内部操作决定的，但在ES6中，通过Symbol.toPrimitive方法可以更改哪个暴露出来的值。<br>　　Symbol.toPrimitive方法被定义在每一个标准类型的原型上，并且规定了当对象被转换为原始值应执行的操作。每当执行原始值转换时，总会调用Symbol.toPrimitive方法并传入一个值作为参数，这个值在规范中被称作类型提示（hint）。类型提示参数的值只有单中选择：”number”、”string”或”default”，传递这些参数时，Symbol.toPrimitive返回的分别时数字，字符串或者无类型偏好的值。<br>　　转换为原始值的顺序：</p><ol><li>调用valueof()方法，如果结果为原始值，则返回。</li><li>否则调用toString()方法，如果结果为原始值，则返回。</li><li>如果再无可选值，则抛出错误。<br>　　在大多数情况下，标准对象会将默认模式按数字模式处理（除了Date对象，在这种情况下，会将默认模式按字符串模式处理）。如果自定义Symbol.toPrimitive方法，则可以覆盖这些默认的强制转换特性。<br>注意：默认模式只用于==，+以及给Date构造函数传递一个参数时。   <h5 id="Symbol-toStringTag属性"><a href="#Symbol-toStringTag属性" class="headerlink" title="Symbol.toStringTag属性"></a>Symbol.toStringTag属性</h5>　　在一个页面中存在多个全局执行环境时，数据来回传递无法检测数据类型。<h6 id="针对类型识别问题的解决方案"><a href="#针对类型识别问题的解决方案" class="headerlink" title="针对类型识别问题的解决方案"></a>针对类型识别问题的解决方案</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === “[object <span class="built_in">Array</span>]”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="在ES6中定义对象字符串标签"><a href="#在ES6中定义对象字符串标签" class="headerlink" title="在ES6中定义对象字符串标签"></a>在ES6中定义对象字符串标签</h6><p>　　在ES6中重新定义了原生对象过去的状态，通过Symbol.toStringTag这个Symbol改变了调用Object.prototype.toString()是返回的身份标识。这个Symbol所代表的的属性在每一个对象中都存在，其定义了调用对象的Object.prototype.toString.call()方法时返回的值。对于数组，调用那个函数返回的通常是”Array”，它正式存储在对象的Symbol.toStringTag属性中。<br>　　同样，可以为自己定义的对象定义Symbol.toStringTag属性。<br>　　注意：除非另有说明，所有对象都会从Symbol.toStringTag这个属性，且默认的属性值”Object”。<br>　　禁止修改内建对象，和将自定义对象的该属性的值修改为内建对象的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;6-Symbol和Symbol属性&quot;&gt;&lt;a href=&quot;#6-Symbol和Symbol属性&quot; class=&quot;headerlink&quot; title=&quot;6.Symbol和Symbol属性&quot;&gt;&lt;/a&gt;6.Symbol和Symbol属性&lt;/h3&gt;&lt;p&gt;　　Symbol是J
      
    
    </summary>
    
      <category term="深入理解ES6" scheme="https://waldosia.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    
    
      <category term="ES6" scheme="https://waldosia.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ES6-第5章-解构：使数据访问更便捷</title>
    <link href="https://waldosia.github.io/2018/03/24/es6_5/"/>
    <id>https://waldosia.github.io/2018/03/24/es6_5/</id>
    <published>2018-03-24T01:13:00.000Z</published>
    <updated>2018-08-05T09:18:19.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="5-解构：使数据访问更便捷"><a href="#5-解构：使数据访问更便捷" class="headerlink" title="5.解构：使数据访问更便捷"></a>5.解构：使数据访问更便捷</h3><h4 id="5-1-为何使用解构功能"><a href="#5-1-为何使用解构功能" class="headerlink" title="5.1 为何使用解构功能"></a>5.1 为何使用解构功能</h4><p>　　从对象和数组中获取相应数据并赋值给变量，代码冗余。</p><h4 id="5-2-对象赋值"><a href="#5-2-对象赋值" class="headerlink" title="5.2 对象赋值"></a>5.2 对象赋值</h4><p>　　对象字面量的语法形式是在一个赋值操作符左边放置一个对象字面量。使用var，let或const声明变量，必须提供初始化程序（也就是等号右侧的值）。</p><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><p>　　我们已经将对象解构应用到了变量的声明中。然而，我们同样可以在给变量赋值时使用解构语法。但是要用一对小括号包裹赋值语句，js引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值的过程。<br>　　解构赋值表达式的值与表达式右侧的值相等。<br>　　解构赋值表达式右侧的值为null或者undefined会导致程序抛出错误。</p><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>　　使用解构赋值表达式时，如果指定的局部变量名称在对象中不存在，那这个局部变量会被赋值为undefined。<br>　　当指定的属性名不存在时，可以随意定义一个默认值，在属性名称后添加一个等号（=）和相应的默认值即可，只有在右边的对象中没有对应的属性或者该属性为undefined时该值生效：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: “Identifier”,</span><br><span class="line">name: “foo”</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;type, name, value = <span class="literal">true</span>&#125; = node;</span><br></pre></td></tr></table></figure></p><h5 id="为非同名局部变量赋值"><a href="#为非同名局部变量赋值" class="headerlink" title="为非同名局部变量赋值"></a>为非同名局部变量赋值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: “Identifier”,</span><br><span class="line">name: “foo”</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">type</span>: localType, <span class="attr">name</span>: localName = “bar” &#125; = node;</span><br></pre></td></tr></table></figure><p>　　上面为为localType和localName赋值。</p><h5 id="嵌套对象赋值"><a href="#嵌套对象赋值" class="headerlink" title="嵌套对象赋值"></a>嵌套对象赋值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">loc: &#123;</span><br><span class="line">start: &#123;</span><br><span class="line">line:<span class="number">1</span>,</span><br><span class="line">column:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123; start &#125;&#125; = node;           <span class="comment">//同名属性</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123; <span class="attr">start</span>: localStart &#125;&#125; = node;  <span class="comment">//不同名属性</span></span><br></pre></td></tr></table></figure><h4 id="5-3-数组解构"><a href="#5-3-数组解构" class="headerlink" title="5.3 数组解构"></a>5.3 数组解构</h4><p>　　使用数组字面量，且解构操作全部在数组内完成。通过值在数组中的位置选取，且可以将其存储在任意变量中。未显示声明的元素直接被忽略。这个过程，原数组不发生变化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [“red”, “green”, “blue”];</span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor] = colors;  <span class="comment">//firstColor=red,secondColor=green</span></span><br><span class="line"><span class="keyword">let</span> [ , , thirdColor] = colors;         <span class="comment">//thirdColor=blue</span></span><br></pre></td></tr></table></figure></p><h5 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h5><p>　　也可用于定义过的变量，但不需要用小括号包裹表达式。<br>变换两个变量的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b] = [b, a];</span><br></pre></td></tr></table></figure></p><p>如果右侧数组解构表达式的值为null或undefined，则会导致程序抛出错误。</p><h5 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h5><p>也可以在数组解构表达式中为数组的任意位置添加默认值，当指定位置的属性不存在或者其值为undefined时使用默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [“red”];</span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor = “green”] = colors;   <span class="comment">//firstColor=red,secondColor=green</span></span><br></pre></td></tr></table></figure></p><h5 id="嵌套数组解构"><a href="#嵌套数组解构" class="headerlink" title="嵌套数组解构"></a>嵌套数组解构</h5><p>　　在原有数组模式中插入另一个数组模式，即可将解构过程深入下一层级。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [“red”, [“green”, “lightGreen”], “blue”];</span><br><span class="line"><span class="keyword">let</span> [firstColor, [secondColor]] = colors;  <span class="comment">//firstColor=red,secondColor=green</span></span><br></pre></td></tr></table></figure></p><h5 id="不定元素"><a href="#不定元素" class="headerlink" title="不定元素"></a>不定元素</h5><p>　　在数组中，可以通过…语法将数组中的奇遇元素赋值给一个特定的变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [“red”, “green”, “blue”];</span><br><span class="line"><span class="keyword">let</span> [firstColor, …restColor] = colors;  <span class="comment">//firstColor=red,restColor=[green,blue]</span></span><br></pre></td></tr></table></figure></p><h5 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [“red”, “green”, “blue”];</span><br><span class="line"><span class="keyword">let</span> […cloneColor] = colors; <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">#### 5.4 混合解构</span></span><br><span class="line"><span class="string">　　可以混合使用对象解构和数组解构来创建更多复杂的表达式。在JSON配置中提取信息时，不再需要遍历整个结构。</span></span><br><span class="line"><span class="string">#### 5.5 解构参数</span></span><br><span class="line"><span class="string">　　当一个接受大量可选参数的JavaScript函数时，我们通常会创建一个可选对象，将额外的参数定义为这个对象的属性：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">setCookie(“type”, “js”, &#123;</span><br><span class="line">secure: <span class="literal">true</span>,</span><br><span class="line">expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="必须传值的解构参数"><a href="#必须传值的解构参数" class="headerlink" title="必须传值的解构参数"></a>必须传值的解构参数</h5><p>　　由于不能讲解构参数赋值给undefined，所以不传值时会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="解构参数的默认值"><a href="#解构参数的默认值" class="headerlink" title="解构参数的默认值"></a>解构参数的默认值</h5><p>　　只需在参数后添加等号并制定一个默认值就行，如果解构参数时可选的，还需将整个解构参数设置一个默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setCookieDefaults = &#123;</span><br><span class="line">secure: <span class="literal">false</span>,</span><br><span class="line">path: “/”,</span><br><span class="line">domain: “example.com”,</span><br><span class="line">expires: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">360000000</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, </span></span></span><br><span class="line"><span class="function"><span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">secure = setCookieDefaults.secure,</span></span></span><br><span class="line"><span class="function"><span class="params">   path = setCookieDefaults.path,</span></span></span><br><span class="line"><span class="function"><span class="params">   domain = setCookieDefaults.domain,</span></span></span><br><span class="line"><span class="function"><span class="params">   expires = setCookieDefaults.expires</span></span></span><br><span class="line"><span class="function"><span class="params">&#125; = setCookieDefaults</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;5-解构：使数据访问更便捷&quot;&gt;&lt;a href=&quot;#5-解构：使数据访问更便捷&quot; class=&quot;headerlink&quot; title=&quot;5.解构：使数据访问更便捷&quot;&gt;&lt;/a&gt;5.解构：使数据访问更便捷&lt;/h3&gt;&lt;h4 id=&quot;5-1-为何使用解构功能&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="深入理解ES6" scheme="https://waldosia.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    
    
      <category term="ES6" scheme="https://waldosia.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ES6-第4章-扩展对象的功能性</title>
    <link href="https://waldosia.github.io/2018/03/20/es6_4/"/>
    <id>https://waldosia.github.io/2018/03/20/es6_4/</id>
    <published>2018-03-20T05:04:00.000Z</published>
    <updated>2018-08-05T09:12:17.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-扩展对象的功能性"><a href="#4-扩展对象的功能性" class="headerlink" title="4.扩展对象的功能性"></a>4.扩展对象的功能性</h3><h4 id="4-1-对象类别"><a href="#4-1-对象类别" class="headerlink" title="4.1 对象类别"></a>4.1 对象类别</h4><ul><li>普通对象：具有JavaScript对象所有的默认内部行为。</li><li>特异对象：具有某些与默认行为不符的内部行为。</li><li>标准对象：ES6规范中定义的对象，例如Array，Date等。标准对象既可以是普通对象，也可以是特异对象。</li><li>内建对象：脚本开始执行时存在于JavaScript执行环境中的对象，所有的标准对象都是内建对象。<h4 id="4-2-对象字面量语法扩展"><a href="#4-2-对象字面量语法扩展" class="headerlink" title="4.2 对象字面量语法扩展"></a>4.2 对象字面量语法扩展</h4><h5 id="属性初始值的简写"><a href="#属性初始值的简写" class="headerlink" title="属性初始值的简写"></a>属性初始值的简写</h5>　　当一个对象的属性与本地变量同名时，不必在写冒号与值，简单只写属性名即可。当对象字面量里只有一个属性的名称时，JavaScript引擎会在可访问作用域中查找同名没变量。<h5 id="对象方法的简写语法"><a href="#对象方法的简写语法" class="headerlink" title="对象方法的简写语法"></a>对象方法的简写语法</h5>　　在ES5及以前，如果为对象添加方法，必须通过指定名称并完整定义函数来实现；而在ES6中，消除冒号与function关键字。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: ‘aaa’,</span><br><span class="line">sayName() &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>　　二者唯一的区别是：简写方法可以使用super关键字。</p><h5 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h5><p>　　在ES5中，如果要通过计算得到属性名，就需要使用方括号代替点记法。有些包括某些字符的字符串字面量作为标识符会出错，其和变量放在方括号中都是被允许的。此外，在对象字面量中，可以直接使用字符串字面量作为属性名称，但是要加上双引号。<br>　　在ES6中可在对象字面量中使用可计算属性名称，其语法与引用对象实例的可计算属性名称相同，也是使用方括号。表示该属性名称时可计算的，它的内容将被求值并被转化为一个字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = <span class="string">"name"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">　　[<span class="string">'first'</span>+suffix]: <span class="string">'aaa'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]);   <span class="comment">//'aaa'</span></span><br></pre></td></tr></table></figure></p><h4 id="4-3-新增方法"><a href="#4-3-新增方法" class="headerlink" title="4.3 新增方法"></a>4.3 新增方法</h4><p>　　ECMAScript其中一个设计目标是：不再创建新的全局函数，也不在Object。prototype上创建新的方法。当开发者想向标准添加新方法时，他们会找一个适当的现有对象，让这些方法可用。结果，当没有其他合适对象时，全局Object对象会收到越来越多的对象方法。ES6中，在全局Object对象上引入了一些新方法。</p><h5 id="Object-is-方法"><a href="#Object-is-方法" class="headerlink" title="Object.is()方法"></a>Object.is()方法</h5><p>　　在js中比较两个值时，一般使用==或===，但是+0和-0在js引擎中为两个完全不同的实体，而全等操作符会判定两者相等，NaN===NaN返回的也是false。<br>　　Object.is()方法来弥补全等操作符的不准确运算。该方法接受两个参数，如果这两个参数类型相同且具有相同的值，则返回true。</p><h5 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign()方法"></a>Object.assign()方法</h5><p>　　该方法接受一个接收对象和任意数量的源对象，并按指定顺序将属性复制（执行的为浅复制）到接收对象中，最终返回接收对象。如果源对象中有同名属性，则排位靠后的源对象会覆盖排位靠前的。<br>　　Object.assign()会将源对象的访问器属性变为数据属性。</p><h4 id="4-4-重复的对象字面量属性"><a href="#4-4-重复的对象字面量属性" class="headerlink" title="4.4 重复的对象字面量属性"></a>4.4 重复的对象字面量属性</h4><p>　　ES5严格模式下会对重复属性报错，而ES6中不再对重复属性报错，但是取值只选取最后一个取值。</p><h4 id="4-5-自有属性枚举顺序"><a href="#4-5-自有属性枚举顺序" class="headerlink" title="4.5 自有属性枚举顺序"></a>4.5 自有属性枚举顺序</h4><p>　　ES6严格规定了对象的自有属性被枚举时的返回顺序，这会影响到Object.getOwnPropertyNames()方法以及Reflect.ownKeys()返回属性的方式，如下：</p><ul><li>所有数字键按升序排序。</li><li>所有字符串键按照它们被加入对象的顺序排序。</li><li>所有symbol键按照它们被加入对象的顺序排序。<h4 id="4-6增强对象原型"><a href="#4-6增强对象原型" class="headerlink" title="4.6增强对象原型"></a>4.6增强对象原型</h4><h5 id="改变对象的原型"><a href="#改变对象的原型" class="headerlink" title="改变对象的原型"></a>改变对象的原型</h5>　　正常情况下，无论是通过构造函数还是Object.create()方法创建对象，其原型是对象被创建时指定的。对象原型在实例化后保持不变。<br>　　所以在ES6中添加Object.setPropertyOf()方法来改变任意指定对象的原型，它接受两个参数：被改变原型的对象及替代第一个参数原型的对象。<h5 id="简化原型的super引用"><a href="#简化原型的super引用" class="headerlink" title="简化原型的super引用"></a>简化原型的super引用</h5>　　super引用相当于指向原型对象的指针，实际上也就是Object.getPropertyOf(this)的值。同样，可以通过super引用调用对象原型上所有其他的方法。当然，必须在使用简写方法的对象中使用super引用。如果在其他方法声明中使用会导致语法错误。<h4 id="4-7-正确的方法定义"><a href="#4-7-正确的方法定义" class="headerlink" title="4.7 正确的方法定义"></a>4.7 正确的方法定义</h4>　　在ES6以前从未正式定义“方法”的概念，方法仅仅是一个具有功能而非数据的对象属性。在ES6中正式将方法定义为一个函数。她会有一个内部的[[HomeObject]]属性来容纳这个方法从属的对象。<br>　　Super的所有引用都通过[[HomeObject]]属性来确定后续的运行过程。第一步是在[[HomeObject]]属性上调用Object.getPrototypeOf()方法来检索原型的引用；然后搜索原型找到同名函数；最后设置this绑定并且调用相应的方法。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;4-扩展对象的功能性&quot;&gt;&lt;a href=&quot;#4-扩展对象的功能性&quot; class=&quot;headerlink&quot; title=&quot;4.扩展对象的功能性&quot;&gt;&lt;/a&gt;4.扩展对象的功能性&lt;/h3&gt;&lt;h4 id=&quot;4-1-对象类别&quot;&gt;&lt;a href=&quot;#4-1-对象类别&quot; cla
      
    
    </summary>
    
      <category term="深入理解ES6" scheme="https://waldosia.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    
    
      <category term="ES6" scheme="https://waldosia.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ES6-第3章-函数</title>
    <link href="https://waldosia.github.io/2018/03/17/es6_3/"/>
    <id>https://waldosia.github.io/2018/03/17/es6_3/</id>
    <published>2018-03-17T04:07:00.000Z</published>
    <updated>2018-08-05T09:03:46.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h3><h4 id="3-1函数形参的默认值"><a href="#3-1函数形参的默认值" class="headerlink" title="3.1函数形参的默认值"></a>3.1函数形参的默认值</h4><h5 id="在ES5中模拟默认参数"><a href="#在ES5中模拟默认参数" class="headerlink" title="在ES5中模拟默认参数"></a>在ES5中模拟默认参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>)</span>&#123;</span><br><span class="line">timeout = timeout || <span class="number">2000</span>;</span><br><span class="line">callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上者缺陷是传入0也会被默认为2000，所以更安全的选择如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>)</span>&#123;</span><br><span class="line">timeout = (<span class="keyword">typeof</span> timeout !== ‘<span class="literal">undefined</span>’) || <span class="number">2000</span>;</span><br><span class="line">callback = (<span class="keyword">typeof</span> callback!== ‘<span class="literal">undefined</span>’) || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="ES6中的默认参数值"><a href="#ES6中的默认参数值" class="headerlink" title="ES6中的默认参数值"></a>ES6中的默认参数值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback = function(</span>)</span>&#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　其中url为必需参数，另两个有默认值。在不传入默认参数或默认参数传入undefined时会使用默认值。有默认值的参数和必需参数顺序无要求。</p><h5 id="默认参数对arguments对象的影响"><a href="#默认参数对arguments对象的影响" class="headerlink" title="默认参数对arguments对象的影响"></a>默认参数对arguments对象的影响</h5><p>　　ES5中在非严格情况下，函数命名参数的变化会体现在arguments中，命名参数被赋予新值时，arguments也相应更新。在严格情况下，取消了这个行为，无论参数怎么变化，arguments对象不再随之变化。<br>　　ES6中如果一个函数是用来默认参数值，则arguments行为与ES5严格模式相同。arguments只与传入的参数有关，默认参数不会给他赋值。</p><h5 id="默认参数表达式"><a href="#默认参数表达式" class="headerlink" title="默认参数表达式"></a>默认参数表达式</h5><p>　　可以通过函数执行来得到默认参数表达式。还可以使用先定义的参数作为后定义参数的默认值，先定义的参数不能访问后定义的参数。</p><h5 id="默认参数的临时死区"><a href="#默认参数的临时死区" class="headerlink" title="默认参数的临时死区"></a>默认参数的临时死区</h5><p>　　与let声明类似，定义参数时会为每一个参数创建一个新的标识符绑定，该绑定在初始化之前不可被引用，如果试图访问会导致程序抛出错误。当调用函数时，会通过传入的值或参数的默认值初始化该参数。<br>　　注意：函数参数有自己的作用域和临时死区，其与函数体的作用域时各自独立的，也就是说参数的默认值不可访问函数体内声明的变量。即括号内可看做是单独的作用域。</p><h4 id="3-2处理无名参数"><a href="#3-2处理无名参数" class="headerlink" title="3.2处理无名参数"></a>3.2处理无名参数</h4><h5 id="ES5中的无名参数"><a href="#ES5中的无名参数" class="headerlink" title="ES5中的无名参数"></a>ES5中的无名参数</h5><p>　　通过arguments来检查函数的所有参数。</p><h5 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h5><p>　　在函数的命名参数前添加三个点（…）就表明这是一个不定参数，该参数为一个数组，包含着自它之后传入的所有参数，通过该数组名可以逐一访问里面的参数。<br>　　注意：函数的length属性统计的是命名参数的数量，不定参数的加入不会影响length的值。</p><h5 id="不定参数的使用限制"><a href="#不定参数的使用限制" class="headerlink" title="不定参数的使用限制"></a>不定参数的使用限制</h5><p>　　每个函数最多只能声明一个不定参数，而且一定要放在所有参数的末尾。<br>　　不定参数不能用于对象字面量setter中，是因为setter的参数有且只能有一个。</p><h5 id="不定参数对arguments的影响"><a href="#不定参数对arguments的影响" class="headerlink" title="不定参数对arguments的影响"></a>不定参数对arguments的影响</h5><p>　　无论是否使用不定参数，arguments对象总是包含所有传入函数的参数。</p><h4 id="3-3-增强的Function构造函数"><a href="#3-3-增强的Function构造函数" class="headerlink" title="3.3 增强的Function构造函数"></a>3.3 增强的Function构造函数</h4><p>　　支持在Function构造函数中传入默认函数以及不定参数。</p><h4 id="3-4展开运算符"><a href="#3-4展开运算符" class="headerlink" title="3.4展开运算符"></a>3.4展开运算符</h4><p>　　展开运算符可以让你指定一个数组，将它们打散后作为各自独立的参数传入函数。ES5及以前需手动遍历或者使用apply()方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values));  <span class="comment">// ES5早期版本 100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(…values));</span><br></pre></td></tr></table></figure></p><p>　　可以将展开运算符与其他正常传入的参数混合使用。</p><h4 id="3-5-name属性"><a href="#3-5-name属性" class="headerlink" title="3.5 name属性"></a>3.5 name属性</h4><p>　　由于JavaScript中有多种定义函数的方式，因此辨别函数就是一项具有挑战性的任务。为此ES6为所有函数新增name属性</p><h5 id="如何选择合适的名称"><a href="#如何选择合适的名称" class="headerlink" title="如何选择合适的名称"></a>如何选择合适的名称</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;  &#125;</span><br><span class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name);  <span class="comment">//”doSomething”</span></span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name);  <span class="comment">//”doAnotherThing”</span></span><br></pre></td></tr></table></figure><p>　　函数声明时name为声明时的函数名称，匿名函数表达式声明时name为被赋值为该匿名函数的变量的名称。</p><h5 id="name属性的特殊情况"><a href="#name属性的特殊情况" class="headerlink" title="name属性的特殊情况"></a>name属性的特殊情况</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params"></span>)</span>&#123;  &#125;;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">get firstName() &#123;</span><br><span class="line"><span class="keyword">return</span> ‘aaa’;</span><br><span class="line">&#125;,</span><br><span class="line">sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name);   <span class="comment">//”doSomethingElse”</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name);  <span class="comment">//”sayName”  </span></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName.name);  <span class="comment">//”get firstName”</span></span><br></pre></td></tr></table></figure><p>　　在这个例子中，doSomething.name的值为”doSomethingElse”，是由于函数表达式有一个名字，这个名字比函数本身被赋值的变量的权重高；对象中的函数为对象字面量；与之类似，person.firstName实际上是一个getter函数，所以名称前面有get前缀，同理setter函数有set前缀。<br>　　通过bind（）函数创建的函数，其名称将带有bound前缀；通过Function构造的函数，名称带有anonymous前缀。<br>　　切记，函数的name属性的值不一定引用同名变量，它只是协助调试用的额外信息，所以不能使用name来获取对函数的引用。</p><h4 id="3-6明确函数的多重用途"><a href="#3-6明确函数的多重用途" class="headerlink" title="3.6明确函数的多重用途"></a>3.6明确函数的多重用途</h4><p>　　ES5及以前函数具有多重功能，可以结合new使用，函数内的this值将指向一个新对象，函数最终将返回这个新对象。<br>　　JavaScript函数中有两个不同的内部方法：[[Call]]和[[Construct]]。当通过new关键字调用函数时，执行的是[[Construct]]函数，它负责创建一个通常被称作实例的新对象，然后再执行函数体，把this绑定在实例上；如果不通过new关键字调用函数，则执行[[Call]]函数，从而执行代码中的函数体。具有[[Construct]]方法的函数被统称为构造函数。<br>　　不是所有函数都有[[Construct]]方法，因此不是所有函数都可以用new来调用。</p><h5 id="在ES5中判断函数被调用的方法"><a href="#在ES5中判断函数被调用的方法" class="headerlink" title="在ES5中判断函数被调用的方法"></a>在ES5中判断函数被调用的方法</h5><p>　　使用instanceof检查this的值，看它是否为构造函数的实例。由于[[Construct]]方法会创建一个Person的新实例，并将this绑定到新实例上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name; </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(‘必须通过<span class="keyword">new</span>关键字调用’);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　但是这种方法也不可靠，因为有一种不依赖new关键字的方法也可以将this绑定到Person实例上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(‘a’);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, ‘b’);  <span class="comment">//有效</span></span><br></pre></td></tr></table></figure></p><p>　　此时将无法区分是通过Person.call()或者apply()还是new关键字调用得到的Person实例。</p><h5 id="元属性（Metaproperty）new-target"><a href="#元属性（Metaproperty）new-target" class="headerlink" title="元属性（Metaproperty）new.target"></a>元属性（Metaproperty）new.target</h5><p>　　元属性指非对象的属性，其可以提供非对象目标的补充信息（如new）。当调用函数的[[Construct]]方法时，new.target被赋值为new操作符的目标，通常是新创建对象实例，也就是函数体内this的构造函数；如果调用[[Call]]方法，则new.target的值为undefined。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== ‘<span class="literal">undefined</span>’) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(‘必须通过<span class="keyword">new</span>关键字调用’);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(‘a’);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, ‘b’);  <span class="comment">//抛出错误</span></span><br></pre></td></tr></table></figure></p><p>　　也可以检查new.target是否被某个特定构造函数调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(‘必须通过<span class="keyword">new</span>关键字调用’);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherPerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(‘a’);</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="keyword">new</span> AnotherPerson (‘b’);  <span class="comment">//抛出错误</span></span><br></pre></td></tr></table></figure></p><p>　　注意：在函数外使用new.target是一个语法错误</p><h4 id="3-7块级函数"><a href="#3-7块级函数" class="headerlink" title="3.7块级函数"></a>3.7块级函数</h4><p>　　ES5的严格模式中引入了一个错误提示，当在代码块内部声明函数时程序会抛出错误。而ES6中会将该函数视作一个块级声明，从而可以在定义该函数的代码块中访问和调用它。该会计函数会被提升到代码块顶部，且代码块外部无法调用它。</p><h5 id="块级函数的使用场景"><a href="#块级函数的使用场景" class="headerlink" title="块级函数的使用场景"></a>块级函数的使用场景</h5><p>　　块级函数与let函数表达式类似，但是let不会提升，而块级函数会被提升。</p><h5 id="非严格模式下的块级函数"><a href="#非严格模式下的块级函数" class="headerlink" title="非严格模式下的块级函数"></a>非严格模式下的块级函数</h5><p>　　这时，这些函数不再提升到代码块的顶部，而是提升至外围函数或全局作用域的顶部。</p><h4 id="3-8箭头函数"><a href="#3-8箭头函数" class="headerlink" title="3.8箭头函数"></a>3.8箭头函数</h4><p>　　箭头函数是一种使用箭头（=&gt;）定义函数的新语法，与传统函数的不同：</p><ul><li>没有this、super、arguments和new.target绑定：箭头函数的this、super、arguments和new.target这些值由外围最近一层非箭头函数决定。</li><li>不能通过new关键字调用：箭头函数没有[[Construct]]方法，所以不能被用作构造函数，通过new调用会报错。</li><li>没有原型：由于不可以通过new调用，因而没有构建原型的需求，所以箭头函数没有prototype这个属性</li><li>不可以改变this的绑定：函数内this不可改变，在函数的生命周期内始终保持一致。</li><li>不支持arguments对象：没有arguments绑定，只能通过命名参数和不定参数访问参数。</li><li>不支持重复的命名参数：无论在严格或非严格情况下，都不支持；而传统函数只有在严格模式下不支持。<br>　　箭头函数也有一个name属性。<h5 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h5>　　箭头函数语法多变，根据实际使用场景有多种形式。所有变种都由函数参数、箭头、函数体组成。<br>a)  当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后，剪头右侧的表达式被求值后便立即返回即使没有返回语句，箭头函数也可以返回传入的第一个参数。<br>b)    如需要传入2个及以上参数，需要在参数两侧加入小括号。<br>c)    如果函数没有参数，也要在声明时写一组没有内容的小括号。<br>d)    如果希望为函数编写由多个表达式组成的函数体，则用花括号包裹住函数体，并显式定义一个返回值。<br>e)    如果想在箭头函数外返回一个对象字面量，则需要将她它包裹在小括号中。为了将其与函数体区分开。<h5 id="创建立即执行函数表达式（IIFE）"><a href="#创建立即执行函数表达式（IIFE）" class="headerlink" title="创建立即执行函数表达式（IIFE）"></a>创建立即执行函数表达式（IIFE）</h5>　　IIFE：定义一个匿名函数并立即调用，自始至终不保存对该函数的引用。当你想创建一个与其他程序隔离的作用域时，这种模式非常方便。<br>　　只要将箭头函数包裹在小括号里，并在最后加入函数调用括号，就可以用它实现相同的功能。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function">(<span class="params">(name</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(‘aaa’);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName());   <span class="comment">//”aaa”</span></span><br></pre></td></tr></table></figure></li></ul><p>　　注意：小括号只包裹箭头函数定义，没有包含(‘aaa’)，这一点与正常函数体有所不同，由正常函数定义的立即执行函数既可以用小括号包裹函数体，也可以额外包裹函数调用的部分。</p><h5 id="箭头函数没有this绑定"><a href="#箭头函数没有this绑定" class="headerlink" title="箭头函数没有this绑定"></a>箭头函数没有this绑定</h5><p>　　箭头函数中没有this绑定，必须通过查找作用域链来决定其值。如果箭头函数被非箭头函数包含，则this绑定的最近一层非箭头函数的this；否则，this的值会被设置为undefined。<br>　　箭头函数缺少正常函数所拥有的的prototype属性，它的设计初衷是“即用即弃”，所以不能用来定义新的类型。如果尝试用过new调用一个箭头函数，会报错。<br>　　不能通过call()、apply()或bind()方法来改变this的值。</p><h5 id="箭头函数与数组"><a href="#箭头函数与数组" class="headerlink" title="箭头函数与数组"></a>箭头函数与数组</h5><p>　　sort()、map()及reduce()，简化回调函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br></pre></td></tr></table></figure></p><h5 id="箭头函数没有arguments绑定"><a href="#箭头函数没有arguments绑定" class="headerlink" title="箭头函数没有arguments绑定"></a>箭头函数没有arguments绑定</h5><p>　　但是可以访问外围函数的arguments对象。</p><h5 id="箭头函数的辨识方法"><a href="#箭头函数的辨识方法" class="headerlink" title="箭头函数的辨识方法"></a>箭头函数的辨识方法</h5><p>　　使用typeof和instanceof调用与普通函数无区别。同样，仍然可以在箭头函数上调用call()、apply()和bind()方法，但箭头函数的this不会改变。</p><h4 id="3-9-调用优化"><a href="#3-9-调用优化" class="headerlink" title="3.9 调用优化"></a>3.9 调用优化</h4><p>　　尾调用指的是函数作为另一个函数的最后一条语句被调用，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doSomethingElse();   <span class="comment">//尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在ES5引擎中，尾调用的实现与其他函数调用的实现类似：创建一个新的栈帧，将其推入调用栈表示函数调用。也就是说，在循环调用是，每一个未用完的栈帧都会保存在内存中，当调用栈变得过大时会造成程序问题。</p><h5 id="ES6中的尾调用优化"><a href="#ES6中的尾调用优化" class="headerlink" title="ES6中的尾调用优化"></a>ES6中的尾调用优化</h5><p>　　ES6缩减了严格模式下尾调用栈的大小（非严格模式下不受影响）。如果满足以下条件，尾调用不再创建新的栈帧，而是清除并重用当前栈帧：</p><ul><li>尾调用不访问当前栈帧的变量（也就是说函数不是一个闭包）。</li><li>在函数内部，尾调用是最后一条语句。</li><li>尾调用的结果作为函数值立即返回。<h5 id="如何利用尾调用优化"><a href="#如何利用尾调用优化" class="headerlink" title="如何利用尾调用优化"></a>如何利用尾调用优化</h5>　　实际上，尾调用的优化发生在引擎背后，除非你尝试优化一个函数，否则无须思考此类问题。递归函数是其最主要的应用场景，此时尾调用优化的效果最显著。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;3-函数&quot;&gt;&lt;a href=&quot;#3-函数&quot; class=&quot;headerlink&quot; title=&quot;3.函数&quot;&gt;&lt;/a&gt;3.函数&lt;/h3&gt;&lt;h4 id=&quot;3-1函数形参的默认值&quot;&gt;&lt;a href=&quot;#3-1函数形参的默认值&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="深入理解ES6" scheme="https://waldosia.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    
    
      <category term="ES6" scheme="https://waldosia.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ES6-第2章-字符串和正则表达式</title>
    <link href="https://waldosia.github.io/2018/03/14/es6_2/"/>
    <id>https://waldosia.github.io/2018/03/14/es6_2/</id>
    <published>2018-03-14T10:24:00.000Z</published>
    <updated>2018-08-05T08:51:03.729Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-字符串和正则表达式"><a href="#2-字符串和正则表达式" class="headerlink" title="2.字符串和正则表达式"></a>2.字符串和正则表达式</h3><h4 id="2-1更好的Unicode支持"><a href="#2-1更好的Unicode支持" class="headerlink" title="2.1更好的Unicode支持"></a>2.1更好的Unicode支持</h4><p>　　在es6出现之前，javascript字符串一直都是基于16位字符编码（UTF-16）进行创建。每16位的序列是一个编码单元，代表一个字符。length、charAt()等字符串属性和方法都是基于这种编码单元构造的。</p><h5 id="UTF-16码位"><a href="#UTF-16码位" class="headerlink" title="UTF-16码位"></a>UTF-16码位</h5><p>　　Unicode的目标时为全世界每一个字符提供全球唯一的字符串（又被称作码位，是从0开始的数值，按顺序排列）。而表示字符的这些数值或码位，我们称之为字符编码（character encode）。字符编码必须将码位编码为内部统一的编码单元。<br>　　对于UTF-16来说，前216个码位均已16位的编码单元表示，这个范围被称作基本多文种平面（BMP）。超出这个范围的码位则要归属于某个辅助平面，其中的码位仅用16位就无法表示了。为此，UTF-16引入了代理对，其规定用两个16位编码单元表示一个码位。也就是说，字符串里的字符有两种，一种是由一个编码单元16位表示的BMP字符，另一种是由两个编码单元32位表示的辅助平面字符。<br>　　在ES5中，所有字符串的操作都基于16位编码单元。如果采用同样的方式处理包含代理对的UTF-16编码字符，得到的结果可能与预期不符。</p><h5 id="codePointAt-方法"><a href="#codePointAt-方法" class="headerlink" title="codePointAt()方法"></a>codePointAt()方法</h5><p>　　方法接受编码单元的位置而非字符串位置作为参数。<br>　　对于非BMP字符集来说，它占用两个编码单元，第一个编码单元codePointAt()返回完整的码位，而第二个编码单元与BMP字符集中字符返回与charCodeAt()相同。<br>　　当该方法返回的数字大于0xFFFF时，为非BMP字符集中字符。</p><h5 id="String-fromCodePoint-方法"><a href="#String-fromCodePoint-方法" class="headerlink" title="String.fromCodePoint()方法"></a>String.fromCodePoint()方法</h5><p>　　参数为码位，根据它生成一个字符。看成完整版的String.fromCharCode()。</p><h5 id="normalize-方法"><a href="#normalize-方法" class="headerlink" title="normalize()方法"></a>normalize()方法</h5><p>　　在对比字符串之前，一定先把它们标准化为同一种形式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first,second</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> firstNormalized = first.normalize();</span><br><span class="line">  <span class="keyword">let</span> secondNormalized = second.normalize();</span><br><span class="line">  <span class="keyword">if</span> (firstNormalized &lt; secondNormalized) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstNormalized === secondNormalized) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="正则表达式u修饰符"><a href="#正则表达式u修饰符" class="headerlink" title="正则表达式u修饰符"></a>正则表达式u修饰符</h5><p>从编码单元操作模式切换为字符模式，可以视代理为一个字符。</p><ul><li>计算码位数量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</span><br><span class="line">  <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>检测空格和非空格字符</p><ul><li>检测u修饰符支持<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasRegExpU</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(‘.’, ‘u’);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2其他字符串变更"><a href="#2-2其他字符串变更" class="headerlink" title="2.2其他字符串变更"></a>2.2其他字符串变更</h4><p>　　字符串中的子串识别</p><ul><li>includes()方法——如果字符串中检测到指定文本则返回true，否则返回false;</li><li>startsWith()方法——如果字符串的起始部分检测到指定文本则返回true，否则返回false；</li><li>endsWith()方法——字符串的结束部分检测到指定文本则返回true；<br>　　以上方法都接收两个参数：第一个是要搜索的文本，第二个参数可选，为开始搜索位置的索引值。Includes()方法和startsWith()方法会从这个索引值的位置开始匹配，endsWith()则从字符串长度减去这个索引值的位置开始匹配，即从后往前数第多少位。参数不能传入正则表达式。<h5 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h5>　　接受一个number参数，表示字符串重复次数，返回值是当前字符串重复一定次数后的新字符串。<h4 id="2-3其他正则表达式语法变更"><a href="#2-3其他正则表达式语法变更" class="headerlink" title="2.3其他正则表达式语法变更"></a>2.3其他正则表达式语法变更</h4><h5 id="正则表达式y修饰符"><a href="#正则表达式y修饰符" class="headerlink" title="正则表达式y修饰符"></a>正则表达式y修饰符</h5>　　它会影响正则表达式搜索过程中的sticky属性，当在字符串中开始字符匹配时，它会通知搜索从正则表达式的lastIndex属性开始进行，若该位置没能匹配成功，则停止继续匹配。<br>　　只有调用exec()和test()这些正则表达式对象方法时才会涉及lastIndex属性；调用字符串方法不会触发粘滞行为。<br>　　检测y修饰符是否存在，应该检测正则表达式的sticky属性。<br>　　可用与u类似的方法来检测引擎支持程度。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasRegExpY</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(‘.’, ‘y’);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="正则表达式的复制"><a href="#正则表达式的复制" class="headerlink" title="正则表达式的复制"></a>正则表达式的复制</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ab/</span>I,</span><br><span class="line">   re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1);</span><br></pre></td></tr></table></figure><p>　　此时re2为re1的一份拷贝，若<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">'g'</span>);</span><br></pre></td></tr></table></figure></p><p>　　在ES5中会抛出错误，而ES6中不会，且修改了re2的修饰符。</p><h5 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h5><p>　　为只读的原型属性访问器，只定义了getter方法。返回所有应用于当前正则表达式的修饰符字符串。source属性可获取正则表达式的文本。</p><h4 id="2-4模板字面量"><a href="#2-4模板字面量" class="headerlink" title="2.4模板字面量"></a>2.4模板字面量</h4><p>　　ES6模板字面量支持创建领域专用语言（DSL）。DSL为某些具体而有限的目标设计的语言。模板字面量草案：这个方案是扩展ECMAScript基础语法的语法糖，其提供一套生成、查询并操作来自其他语言里内容的DSL，且可以免受注入攻击，例如XSS，SQL注入等。<br>　　ES6通过模板字面量的方式进行了填补：</p><ul><li>多行字符串——一个正式的多行字符串的概念。</li><li>基本的字符串格式化——将变量的值嵌入字符串的能力。</li><li>HTML转义——向HTML插入经过安全转换后的字符串的能力。<h5 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h5>　　通过（`）引用。内部使用反撇号时需用\转义。<h5 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h5><h6 id="ES6之前版本中的解决方案"><a href="#ES6之前版本中的解决方案" class="headerlink" title="ES6之前版本中的解决方案"></a>ES6之前版本中的解决方案</h6>　　在一个新行最前方添加反斜杠（\）可以承接上一行的代码。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = “Multiline \</span><br><span class="line">string”;</span><br><span class="line"><span class="built_in">console</span>.log(message);  <span class="comment">//”Multiline string”</span></span><br></pre></td></tr></table></figure></li></ul><p>　　如果想输出新的一行，需要手动输入换行符;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = “Multiline \n\</span><br><span class="line">string”;</span><br><span class="line"><span class="built_in">console</span>.log(message);  <span class="comment">//”Multiline string”</span></span><br></pre></td></tr></table></figure></p><p>　　或者依靠数组和字符串拼接方法建多行字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = [</span><br><span class="line">  <span class="string">"Muitiline"</span>,</span><br><span class="line">  <span class="string">"string"</span></span><br><span class="line">].join(<span class="string">"\n"</span>); </span><br><span class="line"><span class="keyword">let</span> message = “Multiline \n” + “string”;</span><br></pre></td></tr></table></figure></p><h5 id="简化多行字符串"><a href="#简化多行字符串" class="headerlink" title="简化多行字符串"></a>简化多行字符串</h5><p>　　如果需要在字符串中添加新的一行，只需在代码中直接换行，此处的换行结果将同步出现在结果中。<br>　　在反撇号中所有空白符都属于字符串的一部分，所以要千万小心缩进。<br>如果一定要通过适当的缩进来对齐文本，可以砸多行模板字面量中的第一行留白，后面几行缩进，并调用trim()方法移除最初的空格。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;Title&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">html.trim();</span></span><br></pre></td></tr></table></figure></p><p>　　也可以在模板字面量中显示使用\n来插入换行。</p><h5 id="字符串占位符"><a href="#字符串占位符" class="headerlink" title="字符串占位符"></a>字符串占位符</h5><p>　　用${.}表示，内部嵌入JavaScript表达式并将其作为字符串的一部分输出到结果中。一个模板字面量可以嵌套另一个。</p><h5 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h5><p>　　每个模板标签都可以执行模板字面量上的转换并返回最终的字符串值。标签指的是模板字面量第一个反撇号（`）前方标注的字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = tag<span class="string">`Hello world`</span>;</span><br></pre></td></tr></table></figure></p><p>　　改模板字面量标签为tag。</p><h6 id="定义标签"><a href="#定义标签" class="headerlink" title="定义标签"></a>定义标签</h6><h6 id="在模板字面量中使用原始值"><a href="#在模板字面量中使用原始值" class="headerlink" title="在模板字面量中使用原始值"></a>在模板字面量中使用原始值</h6><p>　　使用内建的String.raw标签<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="built_in">String</span>.raw<span class="string">`Multiline\nstring`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message);  <span class="comment">//”Multiline\\nstring”</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2-字符串和正则表达式&quot;&gt;&lt;a href=&quot;#2-字符串和正则表达式&quot; class=&quot;headerlink&quot; title=&quot;2.字符串和正则表达式&quot;&gt;&lt;/a&gt;2.字符串和正则表达式&lt;/h3&gt;&lt;h4 id=&quot;2-1更好的Unicode支持&quot;&gt;&lt;a href=&quot;#2-
      
    
    </summary>
    
      <category term="深入理解ES6" scheme="https://waldosia.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    
    
      <category term="ES6" scheme="https://waldosia.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ES6-第1章-块级作用域绑定</title>
    <link href="https://waldosia.github.io/2018/03/12/es6_1/"/>
    <id>https://waldosia.github.io/2018/03/12/es6_1/</id>
    <published>2018-03-12T08:23:00.000Z</published>
    <updated>2018-08-05T08:31:22.492Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-块级作用域"><a href="#1-块级作用域" class="headerlink" title="1.块级作用域"></a>1.块级作用域</h3><h4 id="1-1Var声明及变量提升（Hosting）机制"><a href="#1-1Var声明及变量提升（Hosting）机制" class="headerlink" title="1.1Var声明及变量提升（Hosting）机制"></a>1.1Var声明及变量提升（Hosting）机制</h4><p>　　在函数作用域中通过关机子var声明的变量，无论实际上是哪里声明的，都会被当成当前作用域顶部声明的变量，这就是我们常说的提升（Hosting）机制   </p><h4 id="1-2-块级声明"><a href="#1-2-块级声明" class="headerlink" title="1.2.    块级声明"></a>1.2.    块级声明</h4><p>　　块级声明用于声明在指定块的组用于之外无法访问的变量。块级作用域（或词法作用域）存在于：   </p><ul><li>函数内部   </li><li>块中（字符{和}之间的区域）<h5 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h5>　　用let代替var来声明变量，就可以把变量的作用域限制在当前代码块中。Let声明不会被提升，需要把let声明放在封闭代码块的顶部。<h5 id="禁止重声明"><a href="#禁止重声明" class="headerlink" title="禁止重声明"></a>禁止重声明</h5>　　假设作用域已经存在某个标识符，此时再使用let关键字声明它就会抛出错误。不管之前是用var还是let声明的。<h5 id="Const声明"><a href="#Const声明" class="headerlink" title="Const声明"></a>Const声明</h5>　　使用const声明的是常量，其值一旦被设定后不可更改。因此，每个通过const声明的常量必须进行初始化。<br>　　与let类似，在同一作用于用const声明已经存在的标识符也会导致语法错误，无论该标识符是使用var还是let声明的。<br>　　无论在严格模式还是在非严格模式下，都不可以为const定义的常量再赋值，否则会抛出错误。<br>　　但是用const声明对象时，不允许修改绑定，但允许修改值。这意味着声明对象后，可以修改该对象的属性值。<h5 id="临时死区（Temporal-Dead-Zone）"><a href="#临时死区（Temporal-Dead-Zone）" class="headerlink" title="临时死区（Temporal Dead Zone）"></a>临时死区（Temporal Dead Zone）</h5>　　与var不同，let和const声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，即使是相对安全的typeof操作符也会触发引用错误。<br>　　因为，let声明之前，该变量还位于临时死区或TDZ中。Javascript引擎在扫描代码发现变量声明时，要么将他们提升至作用域顶部（var），要么将声明放到TDZ中（let和var），访问TDZ中的变量会粗发运行错误。只有执行过变量声明语句后，变量才会从TDZ中移出，方可正常访问。<h5 id="循环中的块作用域绑定"><a href="#循环中的块作用域绑定" class="headerlink" title="循环中的块作用域绑定"></a>循环中的块作用域绑定</h5>　　循环变量用let声明，并且在循环后无法访问到该变量。<h5 id="循环中的let声明"><a href="#循环中的let声明" class="headerlink" title="循环中的let声明"></a>循环中的let声明</h5>　　Let声明模仿IIFE所做的一切来简化循环过程，每次迭代循环都会创建一个新变量，并以之前迭代中的同名变量的值将其初始化。<h5 id="循环中的const声明"><a href="#循环中的const声明" class="headerlink" title="循环中的const声明"></a>循环中的const声明</h5>　　Const不能用在for循环中，但可以用在for-in和for-of中。但是不能改变key的值。<h5 id="全局块作用域绑定"><a href="#全局块作用域绑定" class="headerlink" title="全局块作用域绑定"></a>全局块作用域绑定</h5>　　当var被用于全局作用域时，他会创建一个新的全局变量作为全局对象的属性。这意味着用var可能会无意中覆盖一个已经存在的全局变量。<br> 　　但是如果你在全局作用域中使用let或const，会在全局作用下创建一个新的绑定，但该绑定不会添加为全局变量的属性。<h5 id="块级绑定最佳实践的进化"><a href="#块级绑定最佳实践的进化" class="headerlink" title="块级绑定最佳实践的进化"></a>块级绑定最佳实践的进化</h5>　　默认使用const，只有确实需要改变变量的值时使用let。因为大部分变量的值在初始化后不应再改变，而预料外的变量值的改变是很多bug的源头。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-块级作用域&quot;&gt;&lt;a href=&quot;#1-块级作用域&quot; class=&quot;headerlink&quot; title=&quot;1.块级作用域&quot;&gt;&lt;/a&gt;1.块级作用域&lt;/h3&gt;&lt;h4 id=&quot;1-1Var声明及变量提升（Hosting）机制&quot;&gt;&lt;a href=&quot;#1-1Var声明及
      
    
    </summary>
    
      <category term="深入理解ES6" scheme="https://waldosia.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    
    
      <category term="ES6" scheme="https://waldosia.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>hexo文章编写部分语法总结以及hexo使用</title>
    <link href="https://waldosia.github.io/2018/03/09/MarkDownSummary/"/>
    <id>https://waldosia.github.io/2018/03/09/MarkDownSummary/</id>
    <published>2018-03-09T07:05:00.000Z</published>
    <updated>2018-08-05T08:20:15.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-hexo的使用"><a href="#一-hexo的使用" class="headerlink" title="一.hexo的使用"></a>一.hexo的使用</h2><ul><li><p>1.1 新建一篇文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></li><li><p>1.2. 生成静态文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></li></ul><p>可简写为<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></p><ul><li><p>1.3. 发表草稿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure></li><li><p>1.4. 部署服务器。默认情况下，访问网址为： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></li><li><p>1.5. 部署网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>1.6. 在线编写博客 <a href="http://localhost:4000/admin" target="_blank" rel="noopener">http://localhost:4000/admin</a></p><h2 id="二-语法总结"><a href="#二-语法总结" class="headerlink" title="二. 语法总结"></a>二. 语法总结</h2></li><li>2.1. 换行<br>上一句 + 3个以上空格 + enter + 下一句。   </li><li>2.2. 缩进<br>换成全角符号的空格。   </li><li>2.3. 标题<br>多个#号 + 空格 + 标题文字<br>#号越多字越小，最多支持6个#号   </li><li>2.4. 列表<br>·有序列表<br>数字. + 空格 + 文本<br>·无序列表<br>+/- + 空格 + 文本   </li><li>2.5. 代码区块（适用于Hexo）<br>3个反引号+语言类型（eg.html,css,javaScript）<br>代码块<br>3个反引号 </li><li>2.6. 行内代码<br>用反引号`包裹住代码即可   </li><li>2.7. 链接<br>[链接文字]+(链接网址)     </li><li>2.8. 文章中均可直接插入HTML元素   </li><li>2.9. 利用tabel插入表格时，需要把标签内的空格都去掉。</li></ul><p>只列了一部分，具体参考<a href="http://www.markdown.cn/" target="_blank" rel="noopener">MarkDown</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-hexo的使用&quot;&gt;&lt;a href=&quot;#一-hexo的使用&quot; class=&quot;headerlink&quot; title=&quot;一.hexo的使用&quot;&gt;&lt;/a&gt;一.hexo的使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.1 新建一篇文章&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://waldosia.github.io/tags/Hexo/"/>
    
      <category term="MarkDown" scheme="https://waldosia.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>第一个项目部分总结</title>
    <link href="https://waldosia.github.io/2018/03/08/FirstProjectSummary/"/>
    <id>https://waldosia.github.io/2018/03/08/FirstProjectSummary/</id>
    <published>2018-03-08T09:00:00.000Z</published>
    <updated>2018-08-05T08:20:23.459Z</updated>
    
    <content type="html"><![CDATA[<p>1.移动端头部设置<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span> =<span class="string">"viewport"</span> <span class="attr">content</span> =<span class="string">"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>2.div占据整个body<br>　方法1：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">html</span>&#123;    </span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0px</span>;        </span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0px</span>;          </span><br><span class="line">  <span class="attribute">overflow</span>:hidden;    </span><br><span class="line">&#125;   </span><br><span class="line"><span class="selector-id">#divShow</span>&#123;   </span><br><span class="line">  <span class="attribute">position</span>:absolute;     </span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;   </span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100%</span>;        </span><br><span class="line">  <span class="attribute">background-color</span>:green;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   　方法2：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;      </span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.css3中calc( )函数实现不同单位的运算<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 25<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure></p><p>4.box-sizing属性<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;    </span><br><span class="line">   <span class="attribute">box-sizing</span>:border-box;    </span><br><span class="line">   <span class="attribute">-moz-box-sizing</span>:border-box; <span class="comment">/* Firefox */</span>    </span><br><span class="line">   <span class="attribute">-webkit-box-sizing</span>:border-box; <span class="comment">/* Safari */</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值描述<br><b>content-box:</b><br>这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。<br><b>border-box:</b><br>为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。<br><b>inherit:</b><br>规定应从父元素继承 box-sizing 属性的值。<br>5.用 JavaScript 准确获取手机屏幕的宽度和高度<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewportSize</span> (<span class="params"></span>) </span>&#123;    </span><br><span class="line"><span class="keyword">return</span> &#123;            </span><br><span class="line">    width:<span class="built_in">window</span>.innerWidth||<span class="built_in">document</span>.documentElement.clientWidth||<span class="built_in">document</span>.body.clientWidth,     </span><br><span class="line">    height:<span class="built_in">window</span>.innerHeight||<span class="built_in">document</span>.documentElement.clientHeight||<span class="built_in">document</span>.body.clientHeight     </span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>6.div盒子垂直居中<br>1）盒子没有固定的高度<br>方法1：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span>我不知道我的宽度和高是多少，我要实现水平垂直居中。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;            </span><br><span class="line">    <span class="attribute">position</span>: absolute;            </span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;            </span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;            </span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(-50%, -50%);            </span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">translate</span>(-50%, -50%);            </span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   优点：<br>   1.内容可变高度<br>   2.代码量少<br>   缺点：<br>   1.IE8不支持<br>   2.属性需要写浏览器厂商前缀<br>   3.可能干扰其他transform效果<br>   4.某些情形下会出现文本或元素边界渲染模糊的现象<br>   方法2： 在父级元素上面加上上面3句话，就可以实现子元素水平垂直居中。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;            </span><br><span class="line">   <span class="attribute">width</span>: <span class="number">500px</span>;         </span><br><span class="line">   <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="comment">/*只需要在父元素上加这三句*/</span>            </span><br><span class="line">   <span class="attribute">justify-content</span>: center; <span class="comment">/*子元素水平居中*/</span>            </span><br><span class="line">   <span class="attribute">align-items</span>: center; <span class="comment">/*子元素垂直居中*/</span>            </span><br><span class="line">   <span class="attribute">display</span>: -webkit-flex; <span class="comment">/*css3弹性布局*/</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2）盒子有固定的宽和高<br>方案1、margin 负间距<br>此方案代码关键点：1.必需知道该div的宽度和高度，<br>2.然后设置位置为绝对位置， 3.距离页面窗口左边框和上边框的距离设置为50%，这个50%就是指页面窗口的宽度和高度的50%， 4.最后将该div分别左移和上移，左移和上移的大小就是该DIV宽度和高度的一半。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span>我知道我的宽度和高是多少，我要实现水平垂直居中。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;            </span><br><span class="line">   <span class="attribute">width</span>: <span class="number">400px</span>;            </span><br><span class="line">   <span class="attribute">height</span>: <span class="number">18px</span>;            </span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">20px</span>;            </span><br><span class="line">   <span class="attribute">background</span>: orange;            </span><br><span class="line">   <span class="attribute">color</span>: <span class="number">#fff</span>;            </span><br><span class="line">   <span class="attribute">position</span>: absolute;            </span><br><span class="line">   <span class="attribute">top</span>:<span class="number">50%</span>;            </span><br><span class="line">   <span class="attribute">left</span>:<span class="number">50%</span>;            </span><br><span class="line">   <span class="attribute">margin-top</span>: -<span class="number">9px</span>;            </span><br><span class="line">   <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方案2、<br><code>margin:auto</code>实现绝对定位元素的居中（该方法兼容ie8以上浏览器）<br>此方案代码关键点：<br>1、上下左右均0位置定位；<br>2、<code>margin: auto;</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span>我不知道我的宽度和高是多少，我要实现水平垂直居中。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;            </span><br><span class="line">   <span class="attribute">width</span>: <span class="number">400px</span>;            </span><br><span class="line">   <span class="attribute">height</span>: <span class="number">18px</span>;            </span><br><span class="line">   <span class="attribute">padding</span>:<span class="number">20px</span>;            </span><br><span class="line">   <span class="attribute">background</span>: orange;            </span><br><span class="line">   <span class="attribute">color</span>: <span class="number">#fff</span>;            </span><br><span class="line">   <span class="attribute">position</span>: absolute;            </span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0</span>;            </span><br><span class="line">   <span class="attribute">right</span>:<span class="number">0</span>;            </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;            </span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;            </span><br><span class="line">  <span class="attribute">margin</span>: auto;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.视口单位主要包括以下4个：  </p><ul><li><b>vw :</b>1vw 等于视口宽度的1%   </li><li><b>vh :</b>1vh 等于视口高度的1%   </li><li><b>vmin :</b> 选取 vw 和 vh 中最小的那个   </li><li><b>vmax :</b> 选取 vw 和 vh 中最大的那个 </li></ul><p>7.页面底部居中<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.rule</span>&#123;    </span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100%</span>;    </span><br><span class="line"><span class="attribute">position</span>: fixed;    </span><br><span class="line"><span class="attribute">bottom</span>: <span class="number">2vh</span>;    </span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;    </span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>8.JS手机号正则<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myreg=<span class="regexp">/^[1][3,4,5,7,8][0-9]&#123;9&#125;$/</span>;</span><br></pre></td></tr></table></figure></p><p>9.js中function注释规范<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* [checkMobile 检查号码是否可用]</span></span><br><span class="line"><span class="comment">* @param  &#123;Element&#125; ele   号码输入框</span></span><br><span class="line"><span class="comment">* @param  &#123;string&#125; mbNum</span></span><br><span class="line"><span class="comment">* @param  &#123;Element&#125; pop   弹出框</span></span><br><span class="line"><span class="comment">* @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>10.验证码倒计时<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 点击获取验证码禁用函数</span></span><br><span class="line"><span class="comment">* @param &#123;Element&#125; ele  获取验证码按钮</span></span><br><span class="line"><span class="comment">* @param &#123;Number&#125; time  经过time秒时间后才可以重新获取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codeForbid</span>(<span class="params">ele, time</span>) </span>&#123;</span><br><span class="line">ele.style.backgroundColor = <span class="string">'#999'</span>;</span><br><span class="line">ele.disabled = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(time === <span class="number">0</span>)&#123;</span><br><span class="line">clearInterval(timer);</span><br><span class="line">ele.style.backgroundColor = <span class="string">'#33CCFF'</span>;</span><br><span class="line">ele.innerHTML = <span class="string">'重新获取验证码'</span>;</span><br><span class="line">ele.disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ele.innerHTML = time + <span class="string">"s后重新发送"</span>;</span><br><span class="line">time--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>11.函数内定义全局变量<br>全局环境下定义，函数环境内赋值。<br>12.跨域每次ajax访问后端服务器sessionid不一致问题<br>xhr对象加入withCredentials和crossDomain属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">xhr.crossDomain = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>服务器后端设置头部<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">httpResponse.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);  </span><br><span class="line">httpResponse.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>,<span class="string">"http://192.168.199.240:8081"</span>);  </span><br><span class="line">httpResponse.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With"</span>);</span><br></pre></td></tr></table></figure></p><p>注意由于设置了Access-Control-Allow-Credentials: true，因此必须设置Origin不能使用通配符(*)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpResponse.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>,request.getHeader(<span class="string">'Origin'</span>));</span><br></pre></td></tr></table></figure></p><p>比较通用的写法，获取请求的头部。<br>13.微信分享接口<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;   <span class="comment">//注册微信分享接口</span></span><br><span class="line">debug: <span class="literal">false</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">appId: obj.data.appid, <span class="comment">// 必填，公众号的唯一标识  后端生成</span></span><br><span class="line">timestamp: obj.data.timestamp, <span class="comment">// 必填，生成签名的时间戳   后端生成</span></span><br><span class="line">nonceStr: obj.data.nonceStr, <span class="comment">// 必填，生成签名的随机串  后端生成</span></span><br><span class="line">signature: obj.data.signature,<span class="comment">// 必填，签名   后端生成</span></span><br><span class="line">jsApiList: [<span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line"><span class="string">'checkJsApi'</span>,</span><br><span class="line"><span class="string">'onMenuShareTimeline'</span>,</span><br><span class="line"><span class="string">'onMenuShareAppMessage'</span></span><br><span class="line">]</span><br><span class="line">&#125;);</span><br><span class="line">wx.ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">wx.onMenuShareTimeline(&#123;  分享参数设置</span><br><span class="line">title: title, <span class="comment">// 分享标题</span></span><br><span class="line">link: link, <span class="comment">// 分享链接,将当前登录用户转为puid,以便于发展下线</span></span><br><span class="line">imgUrl: root + <span class="string">'/image/logo.png'</span>, <span class="comment">// 分享图标</span></span><br><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用户确认分享后执行的回调函数</span></span><br><span class="line">alert(<span class="string">'分享成功'</span>);</span><br><span class="line">&#125;,</span><br><span class="line">cancel: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用户取消分享后执行的回调函数</span></span><br><span class="line">alert(<span class="string">'分享失败'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">wx.onMenuShareAppMessage(&#123;</span><br><span class="line">title: title, <span class="comment">// 分享标题</span></span><br><span class="line">desc: desc,</span><br><span class="line">link: link, <span class="comment">// 分享链接,将当前登录用户转为puid,以便于发展下线</span></span><br><span class="line">imgUrl: root + <span class="string">'/image/logo.png'</span>, <span class="comment">// 分享图标</span></span><br><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用户确认分享后执行的回调函数</span></span><br><span class="line">alert(<span class="string">'分享成功'</span>);</span><br><span class="line">&#125;,</span><br><span class="line">cancel: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用户取消分享后执行的回调函数</span></span><br><span class="line">alert(<span class="string">'分享失败'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.移动端头部设置&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;
      
    
    </summary>
    
      <category term="项目总结" scheme="https://waldosia.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="https://waldosia.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>第一天</title>
    <link href="https://waldosia.github.io/2018/02/23/my-first-blog/"/>
    <id>https://waldosia.github.io/2018/02/23/my-first-blog/</id>
    <published>2018-02-23T13:13:33.000Z</published>
    <updated>2018-08-05T08:21:00.848Z</updated>
    
    <content type="html"><![CDATA[<p>waldosia博客的第一天<br>配置博客出现的一些问题<br>1.hexo init 返回 commond not find<br>解决：将hexo所在路径加入到所在环境变量中<br>2.发表文章乱码问题<br>解决：language: zh-Hans,.md文件改为UTF-8编码<br>3.文章编辑代码块<br>3个反引号+语言类型（html,css,javascript）<br>代码块<br>3个反引号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;waldosia博客的第一天&lt;br&gt;配置博客出现的一些问题&lt;br&gt;1.hexo init 返回 commond not find&lt;br&gt;解决：将hexo所在路径加入到所在环境变量中&lt;br&gt;2.发表文章乱码问题&lt;br&gt;解决：language: zh-Hans,.md文件改为U
      
    
    </summary>
    
    
  </entry>
  
</feed>
